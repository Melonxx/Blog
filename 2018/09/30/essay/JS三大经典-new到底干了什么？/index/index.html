<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>JS三大经典-new到底干了什么？ | zch233</title><link rel="stylesheet" type="text/css" href="/Blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/Blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/Blog/favicon.ico"><link rel="apple-touch-icon" href="/Blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/Blog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JS三大经典-new到底干了什么？</h1><a id="logo" href="/Blog/.">zch233</a><p class="description">人到中年</p></div><div id="nav-menu"><a class="current" href="/Blog/."><i class="fa fa-home"> Home</i></a><a href="/Blog/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JS三大经典-new到底干了什么？</h1><div class="post-meta">2018-09-30<span> | </span><span class="category"><a href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%9A%94%E4%B8%A4%E4%B8%AA%E6%9C%88%EF%BC%8C%E7%BB%88%E4%BA%8E%E6%9B%B4%E6%96%B0%E5%95%A6-2018-11-30"><span class="toc-number">1.</span> <span class="toc-text">时隔两个月，终于更新啦~~~~~~ &#x2F;&#x2F; 2018.11.30</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%9F%A5%E4%B9%8E%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">这是一个知乎上的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Answer1-1"><span class="toc-number">3.</span> <span class="toc-text">Answer1.1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Answer1-2"><span class="toc-number">4.</span> <span class="toc-text">Answer1.2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Answer1-3"><span class="toc-number">5.</span> <span class="toc-text">Answer1.3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#prototype-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">prototype 的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%90%86%E8%A7%A3%E4%BA%86-proto-%E5%92%8C-prototype-%E4%BB%A5%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%86%8D%E6%9D%A5%E7%9C%8B%E7%9C%8B-new"><span class="toc-number"></span> <span class="toc-text">在理解了 __proto__ 和 prototype 以后，我们现在再来看看 new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E5%9C%A8%E5%AE%9E%E9%99%85%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%BF%E7%94%A8-proto"><span class="toc-number"></span> <span class="toc-text">首先遇到的问题就是我们无法在实际工作中使用 __proto__</span></a></div></div><div class="post-content"><p>此文先留白思考，哈哈哈哈。</p>
<hr>
<h5 id="时隔两个月，终于更新啦-2018-11-30"><a href="#时隔两个月，终于更新啦-2018-11-30" class="headerlink" title="时隔两个月，终于更新啦~~~~~~ // 2018.11.30"></a>时隔两个月，终于更新啦~~~~~~ <code>// 2018.11.30</code></h5><p>因为 <code>new</code> 牵扯的知识点太多，但又都是必要的。。。<br>篇幅较长，细心慢看&#x3D;。&#x3D;</p>
<hr>
<p>—— 正文开始 ——。</p>
<p><strong>前言：</strong>说new之前，我们首先得了解<code>js</code>的的另一个知识点。</p>
<blockquote>
<p><code>__proto__</code> 和 <code>prototype</code></p>
</blockquote>
<p>由于 <code>es6</code> 新出了 <code>class</code> 关键字以后小白们对于 <code>js</code> 原型的概念更加模糊了。</p>
<p>但是对于 <code>js</code> 老鸟来说想要真正理解 <code>js</code> 这门语言对于原型的理解必须彻底。</p>
<p>js的最大区别其他语言特性之一就是<em><strong>原型</strong></em> (现在还不掌握 <code>__proto__</code> 和 <code>prototype</code> ，那还等到什么时候呢？)</p>
<p><strong>让我们先来看看 <code>__proto__</code> 和 <code>prototype</code> 到底是个啥？</strong></p>
<ol>
<li>你的 JS 代码还没运行的时候，JS 环境里已经有一个 window 对象了</li>
<li>window 对象有一个 Object 属性，window.Object 是一个函数对象</li>
<li>window.Object 这个函数对象有一个重要属性是 prototype，干什么用的等会说</li>
<li>window.Object.prototype 里面有这么几个属性 toString（函数）、valueOf（函数）</li>
</ol>
<p>好，目前先知道这些就够了。然后我们写一句代码</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj.<span class="keyword">to</span><span class="constructor">String()</span></span><br></pre></td></tr></table></figure>
<p>这句代码做了啥？为什么 obj 有 toString() 属性？<br><br><br>这句话大概是让 obj 变量指向一个空对象，这个空对象有个 <strong>proto</strong> 属性指向 window.Object.prototype。</p>
<p>这样你在调用 obj.toString() 的时候，obj 本身没有 toString，就去 obj.<strong>proro</strong> 上面去找 toString。</p>
<p>所以你调用 obj.toString 的时候，实际上调用的是 window.Object.prototype.toString</p>
<p>那么 window.Object.prototype.toString 是怎么获取 obj 的内容的呢？</p>
<p>那是因为 obj.toString() 等价于 obj.toString.call(obj)</p>
<p>同时 obj.toString.call(obj) 等价于 window.Object.prototype.toString.call(obj)这句话把 obj 传给 toString 了。</p>
<p><img src="/Blog/2018/09/30/essay/JS%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8-new%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/index/img.png"></p>
<p>&#x2F;&#x2F; 再看复杂一点的</p>
<p>我们写一句代码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> arr = <span class="selector-attr">[]</span></span><br><span class="line">arr<span class="selector-class">.push</span>(<span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<p>请问这两句话做了什么？<br><br><br>看红色部分，<code>var arr = []</code> 大概会让 <code>arr</code> 指向一个空对象，然后 <code>arr.__proto__</code> 指向 <code>window.Array.prototype</code>。（其实 <code>arr</code> 有一个 <code>length:0</code>，不过这里就忽略吧）</p>
<p>这样你在调用 <code>arr.push</code> 的时候，<code>arr</code> 自身没有 <code>push</code> 属性，就去 <code>arr.__proto__</code> 上找 <code>push</code></p>
<p>因此 <code>arr.push</code> 实际上是 <code>window.Array.prototype.push</code></p>
<p><code>arr.push(1)</code> 等价与 <code>arr.push.call(arr,1)</code></p>
<p><code>arr.push.call(arr,1)</code> 等价于 <code>window.Array.prototype.push.call(arr, 1)</code></p>
<p>&#x2F;&#x2F; 再再复杂一点</p>
<p><code>arr.valueOf()</code> 做了什么?</p>
<p><code>arr</code> 自身没有 <code>valueOf</code>，于是去 <code>arr.__proto__</code> 上找</p>
<p><code>arr.__proto__</code> 只有 <code>pop</code>、<code>push</code> 也没有 <code>valueOf</code>，于是去 <code>arr.__proto__.__proto__</code> 上找</p>
<p><code>arr.__proto__.__proto__</code> 就是 <code>window.Object.prototype</code></p>
<p>所以 <code>arr.valueOf</code> 其实就是 <code>window.Object.prototype.valueOf</code></p>
<p><code>arr.valueOf()</code> 等价于 <code>arr.valueOf.call(arr)</code></p>
<p><code>arr.valueOf.call(arr)</code> 等价于 <code>window.Object.prototype.valueOf.call(arr)</code></p>
<p>看，JavaScript 其实很优美很简单。</p>
<p>只是你想复杂了而已：</p>
<p><code>prototype</code> 指向一块内存，这个内存里面有共用属性</p>
<p><code>__proto__</code> 指向同一块内存</p>
<p><code>prototype</code> 和 <code>__proto__</code> 的不同点在于</p>
<p><code>prototype</code> 是构造函数的属性，而 <code>__proto__</code> 是对象的属性</p>
<p>难点在于……构造函数也是对象！</p>
<p>如果没有 <code>prototype</code>，那么共用属性就没有立足之地</p>
<p>如果没有 <code>__proto__</code>，那么一个对象就不知道自己的共用属性有哪些。</p>
<p>&#x2F;&#x2F; 反证法</p>
<p>假设我们把 <strong>proto</strong> 去掉，那么</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj.<span class="keyword">to</span><span class="constructor">String()</span> <span class="comment">// 报错，没有 toString 方法</span></span><br></pre></td></tr></table></figure>
<p>所以你只能这样声明一个对象咯：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> obj = &#123;</span><br><span class="line">  toString: window<span class="selector-class">.Object</span><span class="selector-class">.prototype</span><span class="selector-class">.toString</span>,</span><br><span class="line">  valueOf: window<span class="selector-class">.Object</span><span class="selector-class">.ptototype</span><span class="selector-class">.valueOf</span></span><br><span class="line">&#125;</span><br><span class="line">obj<span class="selector-class">.toString</span>() <span class="comment">// &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>知道 <strong>proto</strong> 帮你省多少代码了吗？</p>
<p>假设我们删掉 prototype，包括 window.Object.prototype 和 window.Array.prototype。</p>
<p>那么 window.Object.prototype.toString 也一并被删除了。</p>
<p>然后我们基本就没法写代码了……</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">obj</span> = &#123;&#125;</span><br><span class="line">obj.<span class="built_in">toString</span>() // <span class="built_in">toString</span> 不存在，因为 <span class="built_in">toString</span> 没有定义过啊</span><br></pre></td></tr></table></figure>

<p>prototype 的意义就是把共有属性预先定义好，给之后的对象用。<br><br><br>讲到这里，顺带再提一提另外一个相关的知识点。</p>
<p>比如很多人不懂什么是伪数组，</p>
<ol>
<li>很简单：如果一个数组的 <code>__proto__</code> 直接或间接指向 <code>Array.prototye</code>（用到了数组的共用属性），那么就是真数组</li>
<li>如果一个数组的 <code>__proto__</code> 没有直接或间接指向 <code>Array.prototye</code>，那么就是伪数组<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> realArr = &#123;<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>:<span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;</span><br><span class="line">realArr.__proto__ = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="comment">// 这就是真数组（并不完全是）</span></span><br><span class="line"><span class="comment">// 基本等价于 realArr = [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line">realArr.<span class="built_in">push</span> !== <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fakeArr = &#123;<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>:<span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// 这就是伪数组</span></span><br><span class="line">realArr.<span class="built_in">push</span> === <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
因为如此，所以在es6 <code>Array.from(xxx)</code> 的之前，前端才会衍生出 <code>Array.prototype.slice.call(xxx)</code>(如果不理解这里的call啥意思，回退文章列表查阅关于this篇幅) 这种蹩脚的伪数组转数组方法。</li>
</ol>
<blockquote>
<p>ps：看到这里，先停下自己想想吧，没理解的话，也就没有必要再往下看了~</p>
</blockquote>
<br>
<br>
休息一下，继续往下看~
<br>
<br>
<br>
<br>
<br>





<h5 id="这是一个知乎上的问题"><a href="#这是一个知乎上的问题" class="headerlink" title="这是一个知乎上的问题"></a>这是一个知乎上的问题</h5><blockquote>
<p>Question：「为什么明知 JS 的 class 是假的，程序员还不厌其烦地实现 class，而不使用原型」<br>Answer： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/270890846">知乎链接</a></p>
</blockquote>
<p>结论：</p>
<blockquote>
<p>「所有」理解 prototype 的 JS 程序员都能轻松理解 JS 里的 class；<br>反过来，理解 class 的 JS 程序员却「有很多」都理解不了 prototype。</p>
</blockquote>
<p>这就是为什么早年间很大 JS 大神不得不用 prototype 去模拟一个蹩脚的 klass 给新人用。</p>
<p>我没有把 klass 拼错，因为 class 是保留字，所以大神只能用 klass 来「代替」class。</p>
<p>虽然我认为原型是 JS 的基础知识，但是根据实际情况，原型居然变成了 JS 的高级知识，很多新人直接在入门的时候放弃学习原型，而去学 class。</p>
<p>所以，prototype 绝对能让你有智商优越感 :)<br><br><br>好了，开始正经讨论问题。</p>
<ol>
<li>class 的问题<br>　1.1 - class 功能残缺<br>　1.2 - class 使你无法理解 JS 的本质<br>　1.3 - class 不能带来额外的好处，如类型安全</li>
<li>prototype 的问题<br>　2.1 - ES 6 之前大家不想了解 prototype<br>　2.2 - ES 6 之前 prototype 操作不方便</li>
</ol>
<p><em><strong>&#x2F;&#x2F; 第一个问题，功能缺失。</strong></em><br>我是一个实用主义者，如果 class 比 prototype 好用，我绝对会总是使用 class。<br>但是目前情况是：</p>
<ul>
<li>JS 里 class 的功能还不如 prototype</li>
<li>JS 里 class 的功能比 Java 里的 class 更是差了十万八千里</li>
</ul>
<h5 id="Answer1-1"><a href="#Answer1-1" class="headerlink" title="Answer1.1"></a>Answer1.1</h5><p>JS 里 class 的功能还不如 prototype</p>
<p>以 let frank &#x3D; new Human() 为例。如果你要给 Human 加一个 x 属性，怎么加？</p>
<p>对于使用原型的人来说，Human 不就是一个函数对象吗，直接加就是了，何必多此一问：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Human.x</span> = <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>
<p>完</p>
<p>对于使用 class 的人来说，经典 OO 理论会使他倾向与把 Human 看做一个 class，所以应该使用这样的语法</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">1</span>; <span class="comment">// 可惜目前会报语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这个语法，还没有纳入 ES 标准，所以目前在 JS 里用 class 连个静态字段都定义不了，真可惜。</p>
<p>有些人可能会说，那我混用 class 和原型呗：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Human</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Human.x = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果这样写的话 Human 还是类的话，那我就不说什么了。</p>
<p>你问问 Java 程序员能不能理解这样不伦不类的 class。</p>
<p>总之，目前你不可能把 JS 的 class 当成真正的类，你还是得把 Human 看成一个函数对象才行。</p>
<p>有些人可能还会说，我等 class 语法升级不就行了。你都能升级语法了，那我怎么还能说得过你呢，对吧，只要我说 class 哪里有问题你都可以用升级解决。</p>
<p>所以我只讨论目前的 ES 语法。目前使用 class 前你还是需要完全理解 prototype。</p>
<h5 id="Answer1-2"><a href="#Answer1-2" class="headerlink" title="Answer1.2"></a>Answer1.2</h5><p>JS 里 class 的功能比 Java 里的 class 更是差了十万八千里请用 JS 的 class 写出一个抽象类。<br>对不起，目前 class 做不到，等升级语法吧。</p>
<p>JS 的 class 如何实现 private、public 和 protected。</p>
<p>对不起，目前 class 做不到，等升级语法吧。<br><br></p>
<p>可千万别说你可以用其他方法模拟，模拟出个阉割版有意思吗？<br><br></p>
<p>有些人可能会说，class 实现不了我认，你 prototype 不也实现不了吗？大家都实现不了，凭什么说我有问题。<br>这就是一个自相矛盾的地方了，prototype 为什么要去模拟 class 的特性？</p>
<p>在 prototype 体系里，根本就没有类，更遑论抽象类和 private 关键字了。</p>
<p>没有类（class）！</p>
<p>怎么有些人老想着用 JS 模拟 class 呢？<br>不解决这个问题，用 JS 就会总觉得别扭。</p>
<blockquote>
<p>想一想：为什么你非要在一个原型语言里，使用 class 思维来思考问题。</p>
</blockquote>
<p>因为你先入为主地觉得 class 比 prototype 好啊……如果你还没意识自己的问题，恐怕我是真的扳不过来了。</p>
<p>再说一遍：不要把 JS 当做经典面向对象语言（比如 Java）使用。</p>
<p>如果你只学 JS 里的 class 不学 prototype，恐怕最终的后果就是既没有学会经典面向对象，又没有学会原型。<br>方言称之为半吊子，普通话称之为半壶水。</p>
<p>所以 JS 的 class 到底是个啥？</p>
<blockquote>
<p>class 是 prototype 的语法糖而已。</p>
</blockquote>
<p>岂有教人只学习语法糖，不学习真正特性的道理？</p>
<p><em><strong>&#x2F;&#x2F; 第二个问题</strong></em></p>
<p>如果你说我们不能对 JS 这门动态语言要求太多，class 能部分实现 prototype 的功能，够用就行了，没必要再去学习 prototype 了。</p>
<p>那我依然不同意，因为 class 还有一个更严重的问题：</p>
<blockquote>
<p>「只会 class」将使你无法系统理解 JS。</p>
</blockquote>
<p>依然以最简单的代码为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面向对象的解释：Human 类有一个成员方法 sayHi。</p>
<p>只会 class 的同学现在请回答一个问题</p>
<blockquote>
<p>Human 的类型是什么？</p>
</blockquote>
<p>答案是 ‘object’（对象），同时 Human 也是一个函数。class 是一个函数，你不觉得奇怪吗？</p>
<p>再问一个问题，console.dir(Human) 你会看到它有以下属性：</p>
<p><img src="/Blog/2018/09/30/essay/JS%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8-new%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/index/img_1.png"></p>
<blockquote>
<p>请问 Human 为什么有 prototype 属性？<br>为什么 Human.prototype 有一个 sayHi 属性？</p>
</blockquote>
<p>看吧，你始终绕不开原型…… JS 的 class 总会把你引向原型。</p>
<p>我实在是无法理解只会 class 的 JS 开发者要如何理解 JS：</p>
<ol>
<li>你需要无视每个对象的 <strong>proto</strong> 属性</li>
<li>你需要无视每个类的 prototype 属性</li>
</ol>
<p>class 的这个问题才是我反对只学 class 的最关键原因。</p>
<p>无论 JS 的 class 语法如何升级，不管是 ES 6 还是 ES 7、ES 8、ES 9、ES 10、ES 11，都绕不开 prototype。永远都绕不开。因为这是 JS 里对象的本质。</p>
<p>如果绕不开 prototype，你还有什么理由不学 prototype？还有什么理由不好好地、深入地学习 prototype？有些人可能会说，那我先学会 prototype，但是不用 prototype 只用 class 行不行呢？当然行。</p>
<p>但你必须先学会 prototype 呀同学，然后才能理解 class 呀！</p>
<h5 id="Answer1-3"><a href="#Answer1-3" class="headerlink" title="Answer1.3"></a>Answer1.3</h5><p>class 的第三个问题是，class 带来的好处并不多，除了作为糖能让你少写一些代码外，并没有多少额外的好处。用语法糖我不反对，但是如果只用语法糖不学语法糖背后的原理，那我就反对。</p>
<p>有观点认为 class 能使 JS 更加「类型安全」。</p>
<p>持这种观点的人可能对 JS 有误解，一门「没有编译阶段」的「动态」「弱类型」语言怎么可能类型安全啊……JS 任何对象随时都可以被改得面目全非，用了 class 也无济于事。</p>
<p>想要类型安全去用 TypeScript 吧，class 并不能拯救 JS。</p>
<p>而且类型安全属于另一个问题，可以另开帖子讨论。</p>
<p>另外不要以为 TypeScript 里面的 class 跟 JS 里的 class 一样，虽然 TypeScript 是 JS 的超集，但是有编译阶段的 class 和没编译阶段的 class 就是质的区别。</p>
<p>这就是编译的威力。不是 class 的威力</p>
<h5 id="prototype-的问题"><a href="#prototype-的问题" class="headerlink" title="prototype 的问题"></a>prototype 的问题</h5><p>class 这么多问题，难道 prototype 就是完美的吗？<br>如果 prototype 那么好，这么会有这么多人喜欢 class 呢？<br><br><br>JS 的原型比 JS 的 class 好，没说 JS 语言（ES 6 之前）本身有多好。</p>
<p>JS 语言本身（在 ES 6 之前）还是很烂的，为此道格拉斯还专门写了 JS the good parts 这本书来把 JS 为数不多的优点给列出来。</p>
<p>JS 多烂我以后再讨论。但是 JS 的原型绝对是好东西。<br>正如 JS 之父所说：</p>
<blockquote>
<p>它的优秀之处并非原创，它的原创之处并不优秀。——JS 之父引用别人的话描述 JS</p>
</blockquote>
<p>实际上 JS 原创之处全都很垃圾。这个原型就不是 JS 原创的，而且原型很优秀。</p>
<p>所以 prototype 的第一个问题是，它隐藏在 JS 的一堆烂特性中，无法被人发现。</p>
<p>那么第二个问题是什么？</p>
<p>第二个问题是在 ES 6 之前，人们无法很方便地对原型进行操作。</p>
<p>ES 6 之前，你要改变一个对象的原型要怎么做？</p>
<p>你可能会以为这样就可以改变原型：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">xxx</span>.__proto__ = anotherProto<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>但是这个代码很可能报错，因为 __proto__ 到目前为止，都是不推荐使用的特性。</p>
<p>ES 6 出了 Object.create 和 Object.setPrototypeOf 才让开发者能安心操作原型。</p>
<p>那么正确的代码是什么呢？<br><em><strong>敲黑板,敲黑板,敲黑板，重点！(方便理解下面的new)</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyFn = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">emptyFn.<span class="property"><span class="keyword">prototype</span></span> = anotherPrototype</span><br><span class="line">xxx = <span class="keyword">new</span> <span class="title function_">emptyFn</span>()</span><br></pre></td></tr></table></figure>
<p>以上三行代码是 JS 程序不懈努力才发现的实现 <code>xxx.__proto__ = anotherPrototype</code> 的方法。</p>
<p>现在估计你能理解了「为什么在 ES 6 之前，JS 程序员不喜欢 prototype」，因为理解难度实在有点大啊：</p>
<ol>
<li>首先你要耐心学会 JS 的各种烂语法，然后走到 prototype 面前</li>
<li>为了兼容性，你需要用特别奇怪的代码来操作 prototype</li>
</ol>
<p>但是 ES 6 来了之后，这两个问题都解决了呀：</p>
<ol>
<li>JS 的各种烂语法都有对应的修正，如 var 被 let 代替</li>
<li>操作 prototype 很简单了，用 Object.create 就好所以，现在，你应该去学 prototype 了。</li>
</ol>
<p>学会了 prototype，再去学 class 就跟吃糖一样简单。</p>
<h4 id="在理解了-proto-和-prototype-以后，我们现在再来看看-new"><a href="#在理解了-proto-和-prototype-以后，我们现在再来看看-new" class="headerlink" title="在理解了 __proto__ 和 prototype 以后，我们现在再来看看 new"></a>在理解了 <code>__proto__</code> 和 <code>prototype</code> 以后，我们现在再来看看 <code>new</code></h4><p>看了那么久的文字，那就从一个图文并茂的栗子开始看吧 <strong>^ _ ^</strong></p>
<p>想象我们在制作一个策略类战争游戏，玩家可以操作一堆士兵攻击敌方。</p>
<p>我们着重来研究一下这个游戏里面的「制造士兵」环节。</p>
<p>一个士兵的在计算机里就是一堆属性，如下图：</p>
<p><img src="/Blog/2018/09/30/essay/JS%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8-new%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/index/img_2.png" alt="基础士兵"></p>
<p>我们只需要这样就可以制造一个士兵：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 士兵 = &#123;</span><br><span class="line">  ID: <span class="number">1</span>, <span class="comment">// 用于区分每个士兵</span></span><br><span class="line">  兵种:<span class="string">&quot;美国大兵&quot;</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  生命值:<span class="number">42</span>, </span><br><span class="line">  行走:<span class="keyword">function</span><span class="params">()</span>&#123; <span class="comment">/*走俩步的代码*/</span>&#125;,</span><br><span class="line">  奔跑:<span class="keyword">function</span><span class="params">()</span>&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="keyword">function</span><span class="params">()</span>&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="keyword">function</span><span class="params">()</span>&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="keyword">function</span><span class="params">()</span>&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">兵营.制造(士兵)</span><br></pre></td></tr></table></figure>
<p><strong>制造一百个士兵</strong><br>如果需要制造 100 个士兵怎么办呢？</p>
<p>循环 100 次吧：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 士兵们 = []</span><br><span class="line"><span class="keyword">var</span> 士兵</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">  士兵 = &#123;</span><br><span class="line">    <span class="attr">ID</span>: i, <span class="comment">// ID 不能重复</span></span><br><span class="line">    兵种:<span class="string">&quot;美国大兵&quot;</span>,</span><br><span class="line">    攻击力:<span class="number">5</span>,</span><br><span class="line">    生命值:<span class="number">42</span>, </span><br><span class="line">    行走:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*走俩步的代码*/</span>&#125;，</span><br><span class="line">    奔跑:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">    死亡:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">    攻击:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">    防御:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  士兵们.<span class="built_in">push</span>(士兵)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure>
<p>哎呀好简单。</p>
<p><strong>质疑</strong><br>上面的代码存在一个问题：浪费了很多内存。</p>
<ol>
<li>行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100个奔跑……</li>
<li>这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。</li>
<li>只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。</li>
</ol>
<p><strong>改进</strong><br>如果用上文的原型链来做呢~<br>用原型链可以解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 <strong>proto</strong> 指向「士兵原型」</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 士兵原型 = &#123;</span><br><span class="line">  兵种:<span class="string">&quot;美国大兵&quot;</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*走俩步的代码*/</span>&#125;，</span><br><span class="line">  奔跑:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> 士兵们 = []</span><br><span class="line"><span class="keyword">var</span> 士兵</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">  士兵 = &#123;</span><br><span class="line">    <span class="attr">ID</span>: i, <span class="comment">// ID 不能重复</span></span><br><span class="line">    生命值:<span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*实际工作中不要这样写，因为 __proto__ 不是标准属性*/</span></span><br><span class="line">  士兵.__proto__ = 士兵原型 </span><br><span class="line"></span><br><span class="line">  士兵们.<span class="built_in">push</span>(士兵)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure>
<p><strong>优雅？</strong><br>有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 士兵(<span class="params">ID</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> 临时对象 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  临时对象.__proto__ = 士兵.原型</span><br><span class="line"></span><br><span class="line">  临时对象.ID = ID</span><br><span class="line">  临时对象.生命值 = <span class="number">42</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> 临时对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">士兵.原型 = &#123;</span><br><span class="line">  兵种:<span class="string">&quot;美国大兵&quot;</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*走俩步的代码*/</span>&#125;，</span><br><span class="line">  奔跑:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存为文件：士兵.js</span></span><br></pre></td></tr></table></figure>
<p>然后就可以愉快地引用「士兵」来创建士兵了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> 士兵们 = <span class="selector-attr">[]</span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(var i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span></span>&#123;</span><br><span class="line">  士兵们<span class="selector-class">.push</span>(士兵(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure>
<p>but~~~~</p>
<h4 id="首先遇到的问题就是我们无法在实际工作中使用-proto"><a href="#首先遇到的问题就是我们无法在实际工作中使用-proto" class="headerlink" title="首先遇到的问题就是我们无法在实际工作中使用 __proto__"></a>首先遇到的问题就是我们无法在实际工作中使用 <code>__proto__</code></h4><blockquote>
<p>所以JS 之父创建了 <code>new</code> 关键字，可以让我们少写三行代码<br>    ——来自JS 之父的关怀</p>
</blockquote>
<p><img src="/Blog/2018/09/30/essay/JS%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8-new%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/index/img_3.png"></p>
<p>只要你在士兵前面使用 new 关键字，那么可以少做四件事情：</p>
<ol>
<li>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；</li>
<li>不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；</li>
<li>不用 return 临时对象，因为 new 会帮你做；</li>
<li>不要给原型想名字了，因为 new 指定名字为 prototype。</li>
</ol>
<p><strong>这一次我们用 new 来写</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 士兵(<span class="variable constant_">ID</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ID</span> = <span class="variable constant_">ID</span></span><br><span class="line">  <span class="variable language_">this</span>.生命值 = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">士兵.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  兵种:<span class="string">&quot;美国大兵&quot;</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*走俩步的代码*/</span>&#125;,</span><br><span class="line">  奔跑:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存为文件：士兵.js</span></span><br></pre></td></tr></table></figure>
<p>然后是创建士兵（加了一个 new 关键字）：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> 士兵们 = <span class="selector-attr">[]</span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(var i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span></span>&#123;</span><br><span class="line">  士兵们<span class="selector-class">.push</span>(new 士兵(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>new 的作用，就是省那么几行代码。（也就是所谓的语法糖）</p>
</blockquote>
<p>哦对，这其中还有一个叫做 <code>constructor</code> 的属性</p>
<p>new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">士兵.proto<span class="keyword">type</span> = &#123;</span><br><span class="line">  constructor: 士兵</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">士兵.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: xx士兵,</span><br><span class="line">  兵种:<span class="string">&quot;美国大兵&quot;</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*走俩步的代码*/</span>&#125;,</span><br><span class="line">  奔跑:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
end
本文完~

<hr>
<p>最后在更新一道检测题，看你是否真的已经掌握 <code>new</code>(此题有坑)</p>
<p>要求不使用 class，完成如下需求：</p>
<ol>
<li>写出一个构造函数 Animal<br>i.输入为空<br>ii.输出为一个新对象，该对象的共有属性为 <code>&#123;行动: function()&#123;&#125;&#125;</code> ，没有自有属性</li>
<li>再写出一个构造函数 Human<br>i.Human 继承 Animal<br>ii.输入为一个对象，如 <code>&#123;name: &#39;xxx&#39;, birthday: &#39;2000-10-10&#39;&#125;</code><br>iii.输出为一个新对象，该对象自有的属性有 name 和 birthday，共有的属性有物种（人类）、行动和使用工具</li>
<li>在写出一个构造函数 Asian<br>i.Asian 继承 Human<br>ii.输入为一个对象，如 <code>&#123;city: &#39;浙江&#39;, name: &#39;xxx&#39;, birthday: &#39;2000-10-10&#39; &#125;</code><br>iii.输出为一个新对象，改对象自有的属性有 name city 和 bitrhday，共有的属性有物种、行动和使用工具和肤色<br>既<blockquote>
<p>最后一个新对象是 Asian 构造出来的<br>Asian 继承 Human，Human 继承 Animal</p>
</blockquote>
</li>
</ol>
<p>注意，不要使用 class 关键字，请使用原型链（答案可以写在评论区哦~）</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/Blog/2018/10/09/day_thinking/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/index/">如何解决跨域</a><a class="next" href="/Blog/2018/09/29/node_js/NodeJs%E5%B0%86%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6(%E6%88%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6)%E8%BD%AC%E6%8D%A2%E4%B8%BAbase64%EF%BC%88buffer%EF%BC%89/index/">NodeJs将任意文件(或本地文件)转换为base64（buffer）</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'e4a44394ea630529848c',
  clientSecret: '884b4deb2d55fbcc63921e12f73b58e944efa110',
  repo: 'Blog',
  owner: 'zch233',
  admin: ['zch233'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="./about/" title="About"><img class="nofancybox" src="/Blog/img/avatar.png"/></a><p>coder.</p><a class="info-icon" href="zch2333333@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zch233" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Lisp/">Lisp</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Rails/">Rails</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/SCSS/">SCSS</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">chrome调试技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/daisy/">daisy</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/relearnFE/">relearnFE</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95/">准备面试</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E7%96%91/">日常杂疑</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E8%B6%A3%E9%97%BB/">趣闻</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/17/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9AJS-TS/index/">TypeScript全解：JS&TS</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/16/typescript/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/index/">React 泛型组件是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：类型体操（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：类型体操（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：class（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：class（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：泛型编程（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：泛型编程（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/11/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：深入对象与函数（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/11/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：深入对象与函数（上）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.jianshu.com/u/4b4c7aec223d" title="littleyu" target="_blank">littleyu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/Blog/." rel="nofollow">zch233.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/Blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/Blog/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/Blog/css/search.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/Blog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/Blog/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/Blog/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/Blog/js/smartresize.js?v=1.0.0"></script></div></body></html>