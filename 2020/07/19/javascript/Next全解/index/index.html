<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>Next 全解 | zch233</title><link rel="stylesheet" type="text/css" href="/Blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/Blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/Blog/favicon.ico"><link rel="apple-touch-icon" href="/Blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/Blog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Next 全解</h1><a id="logo" href="/Blog/.">zch233</a><p class="description">人到中年</p></div><div id="nav-menu"><a class="current" href="/Blog/."><i class="fa fa-home"> Home</i></a><a href="/Blog/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Next 全解</h1><div class="post-meta">2020-07-19<span> | </span><span class="category"><a href="/Blog/categories/javascript/">javascript</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Next-js-%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">Next.js 的背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E6%98%AF-zeit"><span class="toc-number">1.1.</span> <span class="toc-text">开发团队是 zeit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Next-js-%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.</span> <span class="toc-text">Next.js 的定位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-js-%E5%85%A8%E6%A0%88%E6%A1%86%E6%9E%B6"><span class="toc-number">2.1.</span> <span class="toc-text">Node.js 全栈框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">弱项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Link-%E5%BF%AB%E9%80%9F%E5%AF%BC%E8%88%AA"><span class="toc-number">3.</span> <span class="toc-text">Link 快速导航</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%90%E6%A7%BD"><span class="toc-number">3.3.</span> <span class="toc-text">吐槽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%9E%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">同构代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BB%BD%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9C%A8%E4%B8%A4%E7%AB%AF%EF%BC%88%E7%9C%81%E4%BA%86%E4%B8%80%E4%BB%BD%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">一份代码运行在两端（省了一份）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%B7%AE%E5%BC%82"><span class="toc-number">4.2.</span> <span class="toc-text">注意差异</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">全局配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pages-x2F-app-js"><span class="toc-number">5.1.</span> <span class="toc-text">pages&#x2F;_app.js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">5.2.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-CSS"><span class="toc-number">5.3.</span> <span class="toc-text">全局 CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E5%9C%A8-app-js-%E9%87%8C"><span class="toc-number">5.3.1.</span> <span class="toc-text">放在 _app.js 里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E6%9B%B2"><span class="toc-number">5.3.2.</span> <span class="toc-text">插曲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8-CSS"><span class="toc-number">5.4.</span> <span class="toc-text">局部 CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%94%AF%E6%8C%81"><span class="toc-number">5.4.1.</span> <span class="toc-text">官方支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E4%B8%AA%E4%BA%BA%E4%BD%93%E9%AA%8C"><span class="toc-number">5.4.2.</span> <span class="toc-text">React 个人体验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">5.5.</span> <span class="toc-text">静态资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#next-%E6%8E%A8%E8%8D%90%E6%94%BE%E5%9C%A8-public-%E9%87%8C"><span class="toc-number">5.5.1.</span> <span class="toc-text">next 推荐放在 public 里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89-webpack-config"><span class="toc-number">5.5.2.</span> <span class="toc-text">所以需要配置自定义 webpack config</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-Typescript"><span class="toc-number">6.</span> <span class="toc-text">启用 Typescript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-tsconfig-json"><span class="toc-number">6.1.</span> <span class="toc-text">创建 tsconfig.json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1-yarn-dev"><span class="toc-number">6.2.</span> <span class="toc-text">重启服务 yarn dev</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Next-js-API"><span class="toc-number">7.</span> <span class="toc-text">Next.js API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="toc-number">7.1.</span> <span class="toc-text">目前的页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-number">7.2.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x2F-api-x2F-%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E6%98%AF-API"><span class="toc-number">7.2.1.</span> <span class="toc-text">&#x2F;api&#x2F; 里的文件是 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA-NextAPIHandler"><span class="toc-number">7.2.2.</span> <span class="toc-text">API 文件默认导出 NextAPIHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Next-js-%E4%B8%89%E7%A7%8D%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">Next.js 三种渲染方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">8.1.</span> <span class="toc-text">客户端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90%EF%BC%88SSG%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">静态页面生成（SSG）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">服务端渲染（SSR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A7%E7%93%B6%E8%A3%85%E6%96%B0%E9%85%92"><span class="toc-number">8.4.</span> <span class="toc-text">旧瓶装新酒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94"><span class="toc-number">8.4.1.</span> <span class="toc-text">三种渲染方式分别对应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%90%8E%E7%AB%AF%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">8.4.2.</span> <span class="toc-text">与传统的后端不同点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">客户端渲染的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E5%B1%8F"><span class="toc-number">8.5.1.</span> <span class="toc-text">白屏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEO-%E4%B8%8D%E5%8F%8B%E5%A5%BD"><span class="toc-number">8.5.2.</span> <span class="toc-text">SEO 不友好</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9-VS-%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">8.6.</span> <span class="toc-text">静态内容 VS 动态内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%9B%BE%E7%9A%84%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">8.6.1.</span> <span class="toc-text">上图的静态内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-React-SSR-%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-number">8.6.2.</span> <span class="toc-text">参考 React SSR 的官方文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%AE%BA"><span class="toc-number">8.6.3.</span> <span class="toc-text">推论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90%EF%BC%88SSG%EF%BC%89-1"><span class="toc-number">8.7.</span> <span class="toc-text">静态页面生成（SSG）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">8.7.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getStaticProps-%E8%8E%B7%E5%8F%96-posts"><span class="toc-number">8.7.2.</span> <span class="toc-text">getStaticProps 获取 posts</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.7.2.1.</span> <span class="toc-text">声明位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E5%B0%B1%E6%98%AF%E5%90%8C%E6%9E%84-SSR-%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E4%BC%A0%E7%BB%99%E5%89%8D%E7%AB%AF"><span class="toc-number">8.7.3.</span> <span class="toc-text">这就是同构 SSR 的好处：后端数据可以传给前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF-JSON-parse-%E4%B8%80%E4%B8%8B%E5%B0%B1%E8%83%BD%E5%A4%9F%E5%BE%97%E5%88%B0%E4%BA%86-posts%EF%BC%88%E7%8E%B0%E5%9C%A8-Next-js-%E5%B8%AE%E4%BD%A0%E5%81%9A%E4%BA%86%EF%BC%89"><span class="toc-number">8.7.4.</span> <span class="toc-text">前端 JSON.parse 一下就能够得到了 posts（现在 Next.js 帮你做了）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E9%81%93-PHP-x2F-Java-x2F-Python-%E5%B0%B1%E5%81%9A%E4%B8%8D%E5%88%B0%E4%B9%88"><span class="toc-number">8.7.5.</span> <span class="toc-text">难道 PHP &#x2F; Java &#x2F; Python 就做不到么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">8.7.6.</span> <span class="toc-text">静态化的时机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E8%AF%BB%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6"><span class="toc-number">8.8.</span> <span class="toc-text">解读打包文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9%E9%9D%99%E6%80%81%E5%8C%96"><span class="toc-number">8.9.</span> <span class="toc-text">动态内容静态化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">8.9.1.</span> <span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#getServerSideProps"><span class="toc-number">9.</span> <span class="toc-text">getServerSideProps</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">9.1.</span> <span class="toc-text">用户相关动态内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%B1%E9%9A%BE%E6%8F%90%E5%89%8D%E9%9D%99%E6%80%81%E5%8C%96"><span class="toc-number">9.1.1.</span> <span class="toc-text">就难提前静态化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E4%BB%A5"><span class="toc-number">9.1.2.</span> <span class="toc-text">所以</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-number">9.2.</span> <span class="toc-text">运行时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">10.1.</span> <span class="toc-text">静态内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">10.2.</span> <span class="toc-text">动态内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9%E9%9D%99%E6%80%81%E5%8C%96-1"><span class="toc-number">10.3.</span> <span class="toc-text">动态内容静态化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9%E9%9D%99%E6%80%81%E5%8C%96"><span class="toc-number">10.4.</span> <span class="toc-text">用户相关动态内容静态化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">10.5.</span> <span class="toc-text">流程图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD"><span class="toc-number">11.</span> <span class="toc-text">补充：路由的另一个功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%88%97%E8%A1%A8%E6%9F%A5%E7%9C%8B%E8%AF%A6%E6%83%85%E5%8A%9F%E8%83%BD"><span class="toc-number">11.1.</span> <span class="toc-text">点击列表查看详情功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%86%E6%98%AF%E6%96%B0%E5%BB%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%AB%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">11.2.</span> <span class="toc-text">但是新建的文件叫做什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x2F-pages-x2F-posts-x2F-id-tsx-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">11.3.</span> <span class="toc-text">&#x2F;pages&#x2F;posts&#x2F;[id].tsx 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.4.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="Next-js-的背景"><a href="#Next-js-的背景" class="headerlink" title="Next.js 的背景"></a>Next.js 的背景</h1><h2 id="开发团队是-zeit"><a href="#开发团队是-zeit" class="headerlink" title="开发团队是 zeit"></a>开发团队是 zeit</h2><ul>
<li>zeit 团队<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/59278159/answer/813629215">水平</a>如何。后改名为 Vercel</li>
<li>简言之，一个高中开始编程的、会做平面设计的复旦大学计算机专业毕业生，在微软工作一年后，加入了 zeit 团队</li>
<li>几乎每一个同事都有非常强大的背景</li>
<li>Next,js 核心团队四个人平均年龄 20岁</li>
<li>按 star 数，zeit 是 GitHub 组织的 Top 20</li>
<li>全员远程工作</li>
</ul>
<h1 id="Next-js-的定位"><a href="#Next-js-的定位" class="headerlink" title="Next.js 的定位"></a>Next.js 的定位</h1><h2 id="Node-js-全栈框架"><a href="#Node-js-全栈框架" class="headerlink" title="Node.js 全栈框架"></a>Node.js 全栈框架</h2><ul>
<li>CSS-inJS</li>
<li>页面预渲染 + SSR（服务端渲染）</li>
<li>前后端同构（代码同时运行在两端）</li>
<li>Node.js 10.13 以上</li>
<li>支持 React，与 React 无缝对接</li>
<li>支持 TypeScript</li>
</ul>
<h2 id="弱项"><a href="#弱项" class="headerlink" title="弱项"></a>弱项</h2><ul>
<li>完全没有提供数据库相关功能，可行搭配 Sequelize 或 TypeORM</li>
<li>完全没有提供测试相关功能，可自行搭配 Jest 或 Cypress</li>
<li>有一个叫做 <a target="_blank" rel="noopener" href="https://github.com/blitz-js/blitz">Blitz.js</a> 的框架在这些方向上努力</li>
</ul>
<h1 id="Link-快速导航"><a href="#Link-快速导航" class="headerlink" title="Link 快速导航"></a>Link 快速导航</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>把 <a href=xxx> 点击链接 </a> 改成</li>
<li><Link href=xxx><a> 点击链接 </a></Link></li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>页面不会刷新，用 AJAX 请求新页面内容</li>
<li>不会请求重复的HTML、CSS、JS</li>
<li>自动在页面插入新内容、删除旧内容</li>
<li>因为省了很多请求和解析过程，所以速度极快</li>
</ul>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><ul>
<li>借鉴了 Rails Turbolinks、pjax 等技术</li>
</ul>
<p><img src="/Blog/2020/07/19/javascript/Next%E5%85%A8%E8%A7%A3/index/img.png" alt="传统导航，访问 page2 时是浏览器请求"></p>
<p><img src="/Blog/2020/07/19/javascript/Next%E5%85%A8%E8%A7%A3/index/img_1.png" alt="相比传统导航，访问 page2 时是 page1 用AJAX请求页面（在network中可见）"></p>
<h1 id="同构代码"><a href="#同构代码" class="headerlink" title="同构代码"></a>同构代码</h1><h2 id="一份代码运行在两端（省了一份）"><a href="#一份代码运行在两端（省了一份）" class="headerlink" title="一份代码运行在两端（省了一份）"></a>一份代码运行在两端（省了一份）</h2><ul>
<li>在组件里写一句 console.log(‘执行了’)</li>
<li>你会发现 Node 控制台会输出这句话</li>
<li>同样你会发现 Chrome 控制台也会输出这句话</li>
</ul>
<h2 id="注意差异"><a href="#注意差异" class="headerlink" title="注意差异"></a>注意差异</h2><ul>
<li>不是所有代码都会运行，有些需要用户触发</li>
<li>不是所有的 API 都能用，比如 window 在 Node 里报错</li>
</ul>
<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><h2 id="pages-x2F-app-js"><a href="#pages-x2F-app-js" class="headerlink" title="pages&#x2F;_app.js"></a>pages&#x2F;_app.js</h2><ul>
<li>export default function App 是每个页面的根组件</li>
<li>页面切换时 App 不会销毁，App 里面的组件会销毁</li>
<li>可用 App 保存全局状态</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>创建 _app.js 之后需要重启服务（yarn dev）</li>
</ul>
<h2 id="全局-CSS"><a href="#全局-CSS" class="headerlink" title="全局 CSS"></a>全局 CSS</h2><h3 id="放在-app-js-里"><a href="#放在-app-js-里" class="headerlink" title="放在 _app.js 里"></a>放在 _app.js 里</h3><ul>
<li>import ‘..&#x2F;styles&#x2F;global.css’</li>
<li>因为切换页面时 App 不会销毁</li>
<li>其他地方不能 import global.css</li>
<li>其他地方只能写局部 CSS</li>
</ul>
<h3 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h3><ul>
<li>相对引用好烦，能改成 import ‘style&#x2F;global.css’吗？</li>
<li>文档 <a target="_blank" rel="noopener" href="https://nextjs.org/docs/advanced-features/module-path-aliases">Absolute Import</a> 章节（baseUrl: ‘.’）</li>
</ul>
<h2 id="局部-CSS"><a href="#局部-CSS" class="headerlink" title="局部 CSS"></a>局部 CSS</h2><h3 id="官方支持"><a href="#官方支持" class="headerlink" title="官方支持"></a>官方支持</h3><ul>
<li>默认支持 styled-jsx 和 CSS Modules</li>
<li>一般来说，简单需求用前者，复杂需求用后者</li>
</ul>
<h3 id="React-个人体验"><a href="#React-个人体验" class="headerlink" title="React 个人体验"></a>React 个人体验</h3><ul>
<li>styled-jsx 不方便分离 CSS 和 JS</li>
<li>CSS Modules 用起来太麻烦</li>
<li>styled-components 用起来顺手</li>
</ul>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><h3 id="next-推荐放在-public-里"><a href="#next-推荐放在-public-里" class="headerlink" title="next 推荐放在 public 里"></a>next 推荐放在 public 里</h3><ul>
<li>个人觉得不太好</li>
<li>因为放在 public 里不支持改文件名（如哈希）</li>
</ul>
<h3 id="所以需要配置自定义-webpack-config"><a href="#所以需要配置自定义-webpack-config" class="headerlink" title="所以需要配置自定义 webpack config"></a>所以需要配置自定义 webpack config</h3><ul>
<li>创建 next.config.js</li>
<li>栗子🌰：使用 file-loader 或者 next-images</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file-loader </span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  <span class="attr">webpack</span>: <span class="function">(<span class="params">config, options</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module.rules.<span class="built_in">push</span>(&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif|svg)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name].[contenthash].[ext]&#x27;</span>, <span class="comment">// 文件名称</span></span><br><span class="line">            outputPath: <span class="string">&#x27;static&#x27;</span>, <span class="comment">// 硬盘路径</span></span><br><span class="line">            publicPath: <span class="string">&#x27;_next/static&#x27;</span>, <span class="comment">// 网站路径</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next-images</span></span><br><span class="line"><span class="keyword">const</span> withImages = <span class="built_in">require</span>(<span class="string">&#x27;next-images&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">withImages</span>(&#123;</span><br><span class="line">  <span class="title function_">webpack</span>(<span class="params">config, options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="启用-Typescript"><a href="#启用-Typescript" class="headerlink" title="启用 Typescript"></a>启用 Typescript</h1><h2 id="创建-tsconfig-json"><a href="#创建-tsconfig-json" class="headerlink" title="创建 tsconfig.json"></a>创建 tsconfig.json</h2><ul>
<li>tsc –init 运行后得到 tsconfig.json 或者 touch tsconfig.ts</li>
<li>将 jsconfig.json 里面的配置合并到 tsconfig.json</li>
<li>删除 jsconfig.json</li>
</ul>
<h2 id="重启服务-yarn-dev"><a href="#重启服务-yarn-dev" class="headerlink" title="重启服务 yarn dev"></a>重启服务 yarn dev</h2><ul>
<li>会自动改写 tsconfig.json</li>
<li>更改文件名后缀由 .js 改为 .tsx</li>
<li>不需要一次性将所有文件全部改完</li>
<li><strong>在 tsconfig.json 里添加</strong></li>
<li>“noImlicitAny”: true (禁用隐式的 any)</li>
</ul>
<h1 id="Next-js-API"><a href="#Next-js-API" class="headerlink" title="Next.js API"></a>Next.js API</h1><h2 id="目前的页面"><a href="#目前的页面" class="headerlink" title="目前的页面"></a>目前的页面</h2><ul>
<li>index 和 posts 都是 HTML</li>
<li>但实际开发中我们需要请求 &#x2F;user &#x2F;shops 等 API</li>
<li>但返回的内容是 JSON 格式的字符串</li>
<li><strong>使用 Next.js API</strong></li>
<li>路径为 &#x2F;api&#x2F;v1&#x2F;posts 以便与 &#x2F;posts 区分开来</li>
<li>默认导出的函数的类型为 NextApiHandler</li>
<li>该代码只运行在 Node.js 里，不运行在浏览器中</li>
<li>栗子🌰：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts: NextApiHandler = <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> getPosts() <span class="comment">// 数据库操作</span></span><br><span class="line"> res.end(JSON.stringify(posts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> posts</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="x2F-api-x2F-里的文件是-API"><a href="#x2F-api-x2F-里的文件是-API" class="headerlink" title="&#x2F;api&#x2F; 里的文件是 API"></a>&#x2F;api&#x2F; 里的文件是 API</h3><ul>
<li>一般返回 JSON 格式的字符串</li>
<li>但也不是不能返回 HTML， 比如 res.end(‘&lt;html’&gt;&lt;&#x2F;html’&gt;)</li>
</ul>
<h3 id="API-文件默认导出-NextAPIHandler"><a href="#API-文件默认导出-NextAPIHandler" class="headerlink" title="API 文件默认导出 NextAPIHandler"></a>API 文件默认导出 NextAPIHandler</h3><ul>
<li>这是一个函数类型</li>
<li>第一个参数是请求</li>
<li>第二个参数是对象</li>
<li>因为 Next.js 是基于 Express 的，所以支持 Express 的中间件，下文在分析，<a target="_blank" rel="noopener" href="https://nextjs.org/docs/api-routes/api-middlewares#connectexpress-middleware-support">官方文档</a></li>
</ul>
<h1 id="Next-js-三种渲染方式"><a href="#Next-js-三种渲染方式" class="headerlink" title="Next.js 三种渲染方式"></a>Next.js 三种渲染方式</h1><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h2><ul>
<li>只在浏览器上执行的渲染</li>
</ul>
<h2 id="静态页面生成（SSG）"><a href="#静态页面生成（SSG）" class="headerlink" title="静态页面生成（SSG）"></a>静态页面生成（SSG）</h2><ul>
<li>Static Site Generation，解决白屏问题、SEO问题</li>
<li>无法生成用户相关的内容（所有用户请求的结果都一样）</li>
</ul>
<h2 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h2><ul>
<li>解决白屏问题、SEO 问题</li>
<li>可以生成用户相关内容（不同用户结果不同）</li>
</ul>
<blockquote>
<p>注意：SSR 和 SSG 都属于预渲染 Pre-rendering</p>
</blockquote>
<h2 id="旧瓶装新酒"><a href="#旧瓶装新酒" class="headerlink" title="旧瓶装新酒"></a>旧瓶装新酒</h2><h3 id="三种渲染方式分别对应"><a href="#三种渲染方式分别对应" class="headerlink" title="三种渲染方式分别对应"></a>三种渲染方式分别对应</h3><ul>
<li>客户端渲染 – 用 JS、Vue、React 创建 HTML</li>
<li>SSG – 页面静态化，把 PHP 提前渲染成HTML</li>
<li>SSR – PHP、Python、Ruby、Java 后台的基本功能</li>
</ul>
<h3 id="与传统的后端不同点"><a href="#与传统的后端不同点" class="headerlink" title="与传统的后端不同点"></a>与传统的后端不同点</h3><ul>
<li>Next.js 的预渲染可以与前端 React 无缝对接</li>
</ul>
<h2 id="客户端渲染的缺点"><a href="#客户端渲染的缺点" class="headerlink" title="客户端渲染的缺点"></a>客户端渲染的缺点</h2><h3 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h3><ul>
<li>在 AJAX 得到相应之前，页面中 Loading</li>
</ul>
<h3 id="SEO-不友好"><a href="#SEO-不友好" class="headerlink" title="SEO 不友好"></a>SEO 不友好</h3><ul>
<li>搜索引擎访问页面，看不到 AJAX 得到的数据</li>
<li>因为搜索引擎默认不会执行 JS，只能看到 HTML</li>
</ul>
<h2 id="静态内容-VS-动态内容"><a href="#静态内容-VS-动态内容" class="headerlink" title="静态内容 VS 动态内容"></a>静态内容 VS 动态内容</h2><p><img src="/Blog/2020/07/19/javascript/Next%E5%85%A8%E8%A7%A3/index/img_2.png"></p>
<h3 id="上图的静态内容"><a href="#上图的静态内容" class="headerlink" title="上图的静态内容"></a>上图的静态内容</h3><ul>
<li>是服务渲染的，还是客户端渲染的？</li>
<li>渲染了几次？一次还是两次？</li>
</ul>
<h3 id="参考-React-SSR-的官方文档"><a href="#参考-React-SSR-的官方文档" class="headerlink" title="参考 React SSR 的官方文档"></a>参考 React SSR 的官方文档</h3><ul>
<li>推荐在后端 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-dom-server.html#rendertostring">renderToString() 在前端 hydrate()</a></li>
<li>hydrate() 混合，会保留 HTML 并附上事件监听</li>
<li>也就是说后端渲染 HTML，前端添加监听</li>
<li>前端也会渲染一次，用以确保前后端渲染结果一致（如何看出渲染了两次，当使用 styled-conponents 时会有报错）</li>
</ul>
<h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><ul>
<li>所有页面至少有一个标签是静态内容，由服务端渲染</li>
</ul>
<h2 id="静态页面生成（SSG）-1"><a href="#静态页面生成（SSG）-1" class="headerlink" title="静态页面生成（SSG）"></a>静态页面生成（SSG）</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>你有没有想过，其实每个人看到的文章列表都是一样的</li>
<li>那么为什么还需要在每个人的浏览器渲染一次</li>
<li>为什么不在后端渲染好，然后发给每个人</li>
<li>N 次渲染变成了 1 次渲染</li>
<li>N 次客户端渲染变成了1 次静态页面生成</li>
<li>这个过程叫做<strong>动态内容静态化</strong></li>
</ul>
<h3 id="getStaticProps-获取-posts"><a href="#getStaticProps-获取-posts" class="headerlink" title="getStaticProps 获取 posts"></a>getStaticProps 获取 posts</h3><h4 id="声明位置"><a href="#声明位置" class="headerlink" title="声明位置"></a>声明位置</h4><ul>
<li>每个 page 不是默认导出一个函数么？</li>
<li>把 getStaticProps 声明在这个函数旁边即可</li>
<li>栗子🌰：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStaticProps: GetStaticProps = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> getPosts()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      posts,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须按照这个格式，不能变（命名和返回值{ props: {…} }）</p>
</blockquote>
<p><img src="/Blog/2020/07/19/javascript/Next%E5%85%A8%E8%A7%A3/index/img_3.png"></p>
<blockquote>
<p>打开控制台我们可以清楚的看见，原来我们需要通过 AJAX 的内容，直接被打包进 HTML 里面了，这样浏览器不需要用 AJAX 就可以直接拿到数据了！</p>
</blockquote>
<h3 id="这就是同构-SSR-的好处：后端数据可以传给前端"><a href="#这就是同构-SSR-的好处：后端数据可以传给前端" class="headerlink" title="这就是同构 SSR 的好处：后端数据可以传给前端"></a>这就是同构 SSR 的好处：后端数据可以传给前端</h3><h3 id="前端-JSON-parse-一下就能够得到了-posts（现在-Next-js-帮你做了）"><a href="#前端-JSON-parse-一下就能够得到了-posts（现在-Next-js-帮你做了）" class="headerlink" title="前端 JSON.parse 一下就能够得到了 posts（现在 Next.js 帮你做了）"></a>前端 JSON.parse 一下就能够得到了 posts（现在 Next.js 帮你做了）</h3><h3 id="难道-PHP-x2F-Java-x2F-Python-就做不到么"><a href="#难道-PHP-x2F-Java-x2F-Python-就做不到么" class="headerlink" title="难道 PHP &#x2F; Java &#x2F; Python 就做不到么"></a>难道 PHP &#x2F; Java &#x2F; Python 就做不到么</h3><ul>
<li>其实也可以做到，思路一样</li>
<li>但是他们不支持 JSX，很难与 Reactr 无缝对接</li>
<li>而且他们的对象不能直接提供 JS 用（他们又有 int 之类的类型），需要类型转换</li>
</ul>
<h3 id="静态化的时机"><a href="#静态化的时机" class="headerlink" title="静态化的时机"></a>静态化的时机</h3><ul>
<li>在** 开发环境**，每次请求都会运行一次 getStaticProps</li>
<li>这是为了方便修改代码重新运行</li>
<li>在生产环境，getStaticProps 只会在 build 时运行一次</li>
<li>这样可以提供一份 HTML 给所有用户下载</li>
</ul>
<h2 id="解读打包文件"><a href="#解读打包文件" class="headerlink" title="解读打包文件"></a>解读打包文件</h2><ul>
<li>λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)</li>
<li>○  (Static)  automatically rendered as static HTML (uses no initial props)</li>
<li>●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)</li>
</ul>
<h2 id="动态内容静态化"><a href="#动态内容静态化" class="headerlink" title="动态内容静态化"></a>动态内容静态化</h2><ul>
<li>如果内容与用户无关，那么可以提前静态化</li>
<li>通过 getStaticProps 可以获取数据</li>
<li><strong>静态内容 + 数据（本地获取）</strong> 就得到了完整页面</li>
<li>代替了之前的<strong>静态内容 + 动态内容（AJAX获取）</strong></li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>生产环境中直接给出完整页面</li>
<li>首屏不会白屏</li>
<li>搜索引擎能看到页面内容（方便 SEO）</li>
</ul>
<h1 id="getServerSideProps"><a href="#getServerSideProps" class="headerlink" title="getServerSideProps"></a>getServerSideProps</h1><h2 id="用户相关动态内容"><a href="#用户相关动态内容" class="headerlink" title="用户相关动态内容"></a>用户相关动态内容</h2><h3 id="就难提前静态化"><a href="#就难提前静态化" class="headerlink" title="就难提前静态化"></a>就难提前静态化</h3><ul>
<li>需要在<strong>用户请求时</strong>，获取用户信息，然后<strong>通过用户信息去数据库</strong>拿数据</li>
<li>如果因要做，就要给每个用户都提前创建一个页面（占内存，麻烦）</li>
<li>但还有时候这些数据<strong>更新极快</strong>，无法提前静态化</li>
<li>比如微博首页的信息流</li>
</ul>
<h3 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h3><ul>
<li>要么客户端渲染，下拉更新（1）</li>
<li>要么服务端渲染，下拉更新（2）</li>
<li>但这次的服务端渲染不能用 getStaticProps</li>
<li>因为 getStaticProps 是在 build 时执行的</li>
<li>所以要用 getServerSideProps</li>
</ul>
<h2 id="运行时机"><a href="#运行时机" class="headerlink" title="运行时机"></a>运行时机</h2><ul>
<li>无论是开发环境还是生产环境</li>
<li>都是在<strong>请求到来之后运行</strong> getServerSideProps</li>
<li><em>与 getStaticProps 区别，build 时运行一次</em></li>
</ul>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>context，类型为 NextPageContext</li>
<li>context.req &#x2F; context.res 可以获取请求和响应</li>
<li>一般只需要用到 context.req</li>
<li>栗子🌰：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getServerSideProps: GetServerSideProps = <span class="keyword">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ua = context.req.headers[<span class="string">&quot;user-agent&quot;</span>]</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      ua,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须按照这个格式，不能变（命名和返回值{ props: {…} }）</p>
</blockquote>
<blockquote>
<p>这个栗子展示了用户访问的浏览器，这些信息我们不可能提前（在用户请求之前）知道</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h2><ul>
<li>直接输出 HTML，没有术语</li>
</ul>
<h2 id="动态内容"><a href="#动态内容" class="headerlink" title="动态内容"></a>动态内容</h2><ul>
<li>术语：客户端渲染，通过 AJAX 请求，渲染成 HTML</li>
</ul>
<h2 id="动态内容静态化-1"><a href="#动态内容静态化-1" class="headerlink" title="动态内容静态化"></a>动态内容静态化</h2><ul>
<li>术语：SSG，通过 getStaticProps 获取用户无关内容</li>
</ul>
<h2 id="用户相关动态内容静态化"><a href="#用户相关动态内容静态化" class="headerlink" title="用户相关动态内容静态化"></a>用户相关动态内容静态化</h2><ul>
<li>术语： SSR，通过 getServerSideProps 获取请求</li>
<li>缺点：无法获客户端信息，如浏览器窗口大小</li>
</ul>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/Blog/2020/07/19/javascript/Next%E5%85%A8%E8%A7%A3/index/img_4.png"></p>
<blockquote>
<p>有动态内容吗？没有什么都不用做，自动渲染为 HTML<br>动态内容跟客户端相关？相关就只能用客户端渲染（BSR）<br>动态内容跟请求&#x2F;用户相关吗？相关就只能用服务端渲染（SSR）或 BSR<br>其他情况可以用 SSG 或 BSR</p>
</blockquote>
<h1 id="补充：路由的另一个功能"><a href="#补充：路由的另一个功能" class="headerlink" title="补充：路由的另一个功能"></a>补充：路由的另一个功能</h1><h2 id="点击列表查看详情功能"><a href="#点击列表查看详情功能" class="headerlink" title="点击列表查看详情功能"></a>点击列表查看详情功能</h2><ul>
<li>简单，不就是加个 Link&gt;a 标签吗</li>
<li>href&#x3D;{<code>/post/$&#123;id&#125;</code>}<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/posts/[id]&quot;</span> <span class="attr">as</span>=</span></span><span class="template-variable">&#123;`/posts/$&#123;post.id&#125;</span><span class="language-xml"><span class="tag">`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span></span><span class="template-variable">&#123;post.title&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="但是新建的文件叫做什么"><a href="#但是新建的文件叫做什么" class="headerlink" title="但是新建的文件叫做什么"></a>但是新建的文件叫做什么</h2><ul>
<li>pages&#x2F;posts&#x2F;[id].tsx</li>
<li>没错，文件名就是 [id].tsx，（约定）</li>
</ul>
<h2 id="x2F-pages-x2F-posts-x2F-id-tsx-的作用"><a href="#x2F-pages-x2F-posts-x2F-id-tsx-的作用" class="headerlink" title="&#x2F;pages&#x2F;posts&#x2F;[id].tsx 的作用"></a>&#x2F;pages&#x2F;posts&#x2F;[id].tsx 的作用</h2><ul>
<li>既声明了路由 &#x2F;posts&#x2F;:id</li>
<li>又是 &#x2F;posts&#x2F;:id 的页面实现程序</li>
<li>妙啊</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>用 getServerSideProps 渲染列表页面</li>
<li>详情页用 getStaticProps，从第一个参数接受 params.id</li>
<li>用 getStaticPaths 返回 id 列表</li>
</ul>
<p><img src="/Blog/2020/07/19/javascript/Next%E5%85%A8%E8%A7%A3/index/img_5.png"></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/Blog/2020/07/22/javascript/%E4%BD%BF%E7%94%A8TypeORM/index/">使用 TypeORM</a><a class="next" href="/Blog/2020/07/18/node_js/Koa%E5%85%A8%E8%A7%A3/index/">Koa 全解</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'e4a44394ea630529848c',
  clientSecret: '884b4deb2d55fbcc63921e12f73b58e944efa110',
  repo: 'Blog',
  owner: 'zch233',
  admin: ['zch233'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="./about/" title="About"><img class="nofancybox" src="/Blog/img/avatar.png"/></a><p>coder.</p><a class="info-icon" href="zch2333333@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zch233" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Lisp/">Lisp</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Rails/">Rails</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/SCSS/">SCSS</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">chrome调试技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/daisy/">daisy</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/relearnFE/">relearnFE</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95/">准备面试</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E7%96%91/">日常杂疑</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E8%B6%A3%E9%97%BB/">趣闻</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/08/27/essay/AI%E8%81%8A%E5%A4%A9prompt/index/">AI聊天prompt</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/17/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9AJS-TS/index/">TypeScript全解：JS&TS</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/16/typescript/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/index/">React 泛型组件是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：类型体操（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：类型体操（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：class（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：class（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：泛型编程（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：泛型编程（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/11/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：深入对象与函数（下）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.jianshu.com/u/4b4c7aec223d" title="littleyu" target="_blank">littleyu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/Blog/." rel="nofollow">zch233.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/Blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/Blog/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/Blog/css/search.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/Blog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/Blog/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/Blog/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/Blog/js/smartresize.js?v=1.0.0"></script></div></body></html>