<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>阅读 webpack 源码 | zch233</title><link rel="stylesheet" type="text/css" href="/Blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/Blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/Blog/favicon.ico"><link rel="apple-touch-icon" href="/Blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/Blog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">阅读 webpack 源码</h1><a id="logo" href="/Blog/.">zch233</a><p class="description">人到中年</p></div><div id="nav-menu"><a class="current" href="/Blog/."><i class="fa fa-home"> Home</i></a><a href="/Blog/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">阅读 webpack 源码</h1><div class="post-meta">2021-04-22<span> | </span><span class="category"><a href="/Blog/categories/javascript/">javascript</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">第一个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">第二个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hooks-xxx-call-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">hooks.xxx.call 是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">新的第二个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%BE%85%E8%A1%A5%E5%85%85"><span class="toc-number">4.</span> <span class="toc-text">流程图待补充</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">第三个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">第四个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">第五个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">第六个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">第七个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">第八个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">第九个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">第十个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">12.0.1.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><blockquote>
<p><a href="mailto:&#119;&#x65;&#x62;&#x70;&#x61;&#99;&#107;&#x40;&#x35;&#x2e;&#x31;&#x30;&#46;&#49;">&#119;&#x65;&#x62;&#x70;&#x61;&#99;&#107;&#x40;&#x35;&#x2e;&#x31;&#x30;&#46;&#49;</a><br><a href="mailto:&#119;&#x65;&#98;&#x70;&#97;&#x63;&#x6b;&#x2d;&#x63;&#108;&#105;&#64;&#x34;&#x2e;&#x32;&#46;&#48;">&#119;&#x65;&#98;&#x70;&#97;&#x63;&#x6b;&#x2d;&#x63;&#108;&#105;&#64;&#x34;&#x2e;&#x32;&#46;&#48;</a><br>阅读源码小技巧：折叠所有代码，先不看所有的变量声明和 require，要是之后用到再看，直接看主要逻辑。<br>带着问题看源码</p>
</blockquote>
<h1 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h1><ul>
<li><strong>webpack-cli 是如何调用 webpack 的</strong></li>
<li>在 demo 目录运行 webpack-cli，会自动把 src&#x2F;index.js 打包为 dist&#x2F;main.js</li>
<li>显然会调用 webpack 来打包，那么请问是如何做到的</li>
</ul>
<ol>
<li>首先当我们运行 webpack-cli 命令的时候，会去执行 bin&#x2F;cli.js 。</li>
<li>折叠文件所有代码，跳过 require 和所有声明，第一个 if 不看，之后的 if else 就需要打开来看了，因为这段话必定要执行，我们先假设 webpack 存在，进入 runCli 这个函数。</li>
<li>折叠所有代码，直接看主分支 try catch 里面，主要调用了 cli.run 这个方法。</li>
<li>进入 cli.run，第一个方法 <code>this.runOptionGroups(args)</code> 从名字可以看出和配置项相关，所以跳过，最后发现执行了 <code>this.createCompiler</code> 这个函数。</li>
<li>进入 createCompiler 并折叠函数，我们发现他其实就是调用了 webpack 这个函数。</li>
</ol>
<p><img src="/Blog/2021/04/22/javascript/%E9%98%85%E8%AF%BBwebpack%E6%BA%90%E7%A0%81/index/img.gif" alt="阅读全过程"></p>
<ul>
<li><strong>看完源码之后明白</strong></li>
<li>compiler &#x3D; webpack(options, callback)</li>
<li>webpack &#x3D; require(‘webpack’)</li>
<li>webpack-cli 就是这么调用 webpack 的</li>
</ul>
<h1 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h1><ul>
<li><strong>webpack 是如何分析 index.js 的</strong></li>
<li>通过之前自己做的简易打包器，打包器需要先分析并收集依赖，然后打包成一个文件</li>
<li>那么 webpack 肯定也做了这件事</li>
<li>显然 webpack 也需要分析 AST，不可能用正则来做</li>
</ul>
<p><img src="/Blog/2021/04/22/javascript/%E9%98%85%E8%AF%BBwebpack%E6%BA%90%E7%A0%81/index/img_1.gif" alt="阅读全过程"></p>
<ol>
<li>直接看 webpack 的 package.json 的 main 属性，可以得知入口是 lib&#x2F;index.js。</li>
<li>进入 index.js，主要是导出了一个函数，这个函数又是从 ‘.&#x2F;webpack’ 里面的。</li>
<li>进入 ‘.&#x2F;webpack’，也是主要导出了一个webpack 这个函数，第一个函数 <code>validateSchema</code> 是验证函数（不看），然后是 一个 if else，一般我们用 webpck 的时候，options 一般都不会是一个数组，所以我们看 else，执行了 一个 createCompiler 函数。</li>
<li>懵逼了，凭我目前的认知，看不懂这套逻辑了，createCompiler 就是 return 了一个 new Compiler，compiler.hooks.xxx.call 干了什么，猜测主要逻辑应该在这个里面（排除法）。</li>
</ol>
<ul>
<li><strong>看了源码之后发现</strong></li>
<li>看了半天，就发现创建了一个compiler 对象，然后什么都没做</li>
<li>hooks.xxx.call 是什么鬼？</li>
<li>看源码不是好的学习方式，性价比低</li>
<li>第一次劝退</li>
</ul>
<h2 id="hooks-xxx-call-是什么"><a href="#hooks-xxx-call-是什么" class="headerlink" title="hooks.xxx.call 是什么"></a>hooks.xxx.call 是什么</h2><ul>
<li><strong>Tapable</strong></li>
<li>这是 webpack 团队为了写 wepack 而写的一个事件&#x2F;钩子库（也就是发布订阅）</li>
<li><strong>用法</strong></li>
<li>定义一个事件&#x2F;钩子</li>
<li>this.hooks.eventName &#x3D; new SyncHook([‘arg1’, ‘arg2’]);</li>
<li>监听一个事件&#x2F;钩子</li>
<li>this.hooks.eventName.tap(‘监听理由’, fn)</li>
<li>触发一个事件&#x2F;钩子</li>
<li>this.hooks.eventName.call(‘arg1’, ‘arg2’)<blockquote>
<p>教训：看源码时，遇到不懂的，要快速学会</p>
</blockquote>
</li>
</ul>
<h1 id="新的第二个问题"><a href="#新的第二个问题" class="headerlink" title="新的第二个问题"></a>新的第二个问题</h1><ul>
<li><strong>webpack 的流程是怎么样的</strong></li>
<li>webpack 把打包分为了哪几个阶段（事件或钩子）</li>
<li><strong>看完代码发现</strong></li>
<li>至少有 env init run beforeCompile compile compilation make finishMake afterCompile emit 这几个钩子</li>
</ul>
<h1 id="流程图待补充"><a href="#流程图待补充" class="headerlink" title="流程图待补充"></a>流程图待补充</h1><h1 id="第三个问题"><a href="#第三个问题" class="headerlink" title="第三个问题"></a>第三个问题</h1><ul>
<li><strong>读取 index.js 并分析和收集依赖是在哪个阶段？</strong></li>
<li>用排除法可以知道，肯定不是 env 和 emit，肯定在 beforeCompile 和 afterCompile 之间</li>
<li>最有可能是在 make - finishMake 阶段（为什么？）</li>
<li>学过 C 语言就会知道，make 是编译时必然会用到的工具，可见很重要</li>
<li><strong>验证想法</strong></li>
<li>我们发现 make - finishMake 之间什么代码都没有</li>
</ul>
<h1 id="第四个问题"><a href="#第四个问题" class="headerlink" title="第四个问题"></a>第四个问题</h1><ul>
<li><strong>make - finishMake 之间，做了什么</strong></li>
<li>搜索 make.tap，发现很多监听了 make 事件</li>
<li>还是根据排除法，应该是 EntryPlugin（<strong>由此发现 webpack 为什么什么都不做呢，因为 webpack 只是把流程安排好，其他事情都交给插件去做，webpack 架构就是事件模型，你要做什么事情，你自己去找相对应的钩子去插入就好了</strong>）</li>
<li>EntryPlugin 的 addEntry 函数就是 make 阶段最重要的事情之一</li>
<li><strong>死胡同</strong></li>
<li>跟代码跟到 factorizeQueue 就发现没有后续代码了，怎么办？</li>
<li><strong>第三次劝退</strong></li>
<li>需要补充任务队列知识，任务队列发现有任务会自动执行</li>
</ul>
<h1 id="第五个问题"><a href="#第五个问题" class="headerlink" title="第五个问题"></a>第五个问题</h1><ul>
<li><strong>factor.create 是什么东西</strong></li>
<li>这个 factor 是哪里来的？</li>
<li>是从 factorizeModule(options 的 options.factory 来的)</li>
<li>这个 options.factory 是哪里来的？</li>
<li>是从 moduleFactory 来的</li>
<li>moduleFactory 哪里来的？</li>
<li>是用 this.dependencyFactories.get(Dep) 得到的</li>
<li>this.dependencyFactories.get(Dep) 是个啥？</li>
<li>你搜 compilation.tap 就知道，他是 normalModuleFactory，简称 <em><strong>nmf</strong></em></li>
<li>结论：factor 就是 nmf，所以 factory.create 就是 nmf.create</li>
</ul>
<h1 id="第六个问题"><a href="#第六个问题" class="headerlink" title="第六个问题"></a>第六个问题</h1><ul>
<li><strong>nmf.create 做了什么</strong></li>
<li>来到 NormalModuleFactory.js，可以看到 create 的代码</li>
<li>只发现一具有用的代码：beforeResolve.call 和 factorize.call</li>
<li>搜索两者对应的 tap，发现 factorize.tap 里面有重要代码</li>
<li>他触发了 resolve，而 resolve 主要是在收集 loaders</li>
<li>然后他触发了 createModule，得到了 createdModule</li>
<li>也就是说，nmf.create 得到了一个 module 对象</li>
<li>等价于 factor.create 得到了一个 module 对象</li>
<li>回想一下，我们怎么找到 factory.create 的？</li>
<li>你可以使用 back 功能回来之前的停顿点</li>
<li>我们是从 factorizeModule 来到 factory.create 的</li>
<li>回来 factorizeModule，发现后续操作是 addModule 和 buildModule</li>
</ul>
<h1 id="第七个问题"><a href="#第七个问题" class="headerlink" title="第七个问题"></a>第七个问题</h1><ul>
<li><strong>addModule 做了什么</strong></li>
<li>把module 添加到 compilation.modules 里</li>
<li>而且还通过检查 id 防止重复添加</li>
</ul>
<h1 id="第八个问题"><a href="#第八个问题" class="headerlink" title="第八个问题"></a>第八个问题</h1><ul>
<li><strong>buildModule 做了什么</strong></li>
<li>看名字就知道是重要操作，它调用了 module.build()</li>
<li>来到 NormalModule.js（猜的，跟 nmf 差不多） 看 build 源码，发现了 runLoaders</li>
<li>然后来到 processResult()，发现了 _source &#x3D; … 和 _ast &#x3D; null</li>
<li>这是要做什么？显然是要把 _source 变成 _ast 了！</li>
<li>这就是我们第二个问题（webpack 如何分析 index.js） 的答案！</li>
<li>来到 doBuild 的回调，发现了 this.parser.parse()！</li>
<li>终于，着整个过程就是最开始我们的简易打包器的过程（AST、Babel、依赖）</li>
<li>parse 就是把 code 变成 ast</li>
<li>问题来了，parser 是什么，parse() 的源码在哪儿？</li>
<li>继续跟代码会发现 parser （javascriptParser.js）来自于acorn 库，需要编译原理知识（涉及到盲区了）</li>
</ul>
<h1 id="第九个问题"><a href="#第九个问题" class="headerlink" title="第九个问题"></a>第九个问题</h1><ul>
<li><strong>webpack 如何知道 index.js 依赖了那些文件的</strong></li>
<li>目前我们知道 webpack 会对 index.js 进行 parse 得到 ast</li>
<li>那么接下来 webpack 应该会 traverse 这个 ast，寻找 import 语句</li>
<li>那么相关代码在哪儿？</li>
<li><strong>阅读源码发现</strong></li>
<li>JavascriptParser.js 的 3231 行得到 ast，3260~3264 行 traverse 了 ast</li>
<li>其中 blockPreWalkStatement() 对 ImportDeclaration 进行了检查</li>
<li>一旦发现 import ‘xxx’，就会触发 import 钩子，对应的监听函数会处理依赖</li>
<li>其中 walkStatements() 对 importExpression 进行了检查</li>
<li>一旦发现 import(‘xxx’)，就会触发 importCall 钩子，对应的监听函数也会</li>
</ul>
<h1 id="第十个问题"><a href="#第十个问题" class="headerlink" title="第十个问题"></a>第十个问题</h1><ul>
<li><strong>怎么把 Modules 合并成一个文件的？</strong></li>
<li>看 compilation.seal()（猜的，只剩这个阶段了），该函数会创建 chunks、 为每个 chunk 进行 codeGeneration，然后为每个 chunk 创建 asset（搜索 write，发现writeOut）</li>
<li>seal() 之后，emitAssets()、emitFiles() 会创建文件</li>
<li>最终得到 dist&#x2F;main.js 和其他 chunk 文件</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>webpack 怎么分析依赖和打包的</strong></li>
<li>使用 JavascriptParser 对 index.js 进行 parse 得到 ast，然后遍历 ast</li>
<li>发现依赖声明就将其添加到 module 的 dependencies 或 blocks 中</li>
<li>seal 阶段，webpack 将 module 转为 chunk，可能会把多个 module 通过 codeGeneration 合并为一个 chunk</li>
<li>seal 之后，为每个 chunk 创建文件，并写到硬盘上</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/Blog/2021/04/22/javascript/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index/">Web性能优化-什么是多路复用</a><a class="next" href="/Blog/2021/04/18/essay/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8composition-api/index/">为什么要使用 composition-api</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'e4a44394ea630529848c',
  clientSecret: '884b4deb2d55fbcc63921e12f73b58e944efa110',
  repo: 'Blog',
  owner: 'zch233',
  admin: ['zch233'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="./about/" title="About"><img class="nofancybox" src="/Blog/img/avatar.png"/></a><p>coder.</p><a class="info-icon" href="zch2333333@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zch233" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Lisp/">Lisp</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Rails/">Rails</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/SCSS/">SCSS</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">chrome调试技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/daisy/">daisy</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/relearnFE/">relearnFE</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95/">准备面试</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E7%96%91/">日常杂疑</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E8%B6%A3%E9%97%BB/">趣闻</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/17/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9AJS-TS/index/">TypeScript全解：JS&TS</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/16/typescript/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/index/">React 泛型组件是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：类型体操（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：类型体操（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：class（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：class（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：泛型编程（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：泛型编程（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/11/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：深入对象与函数（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/11/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：深入对象与函数（上）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.jianshu.com/u/4b4c7aec223d" title="littleyu" target="_blank">littleyu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/Blog/." rel="nofollow">zch233.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/Blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/Blog/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/Blog/css/search.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/Blog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/Blog/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/Blog/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/Blog/js/smartresize.js?v=1.0.0"></script></div></body></html>