<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>杜绝使用 npm | zch233</title><link rel="stylesheet" type="text/css" href="/Blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/Blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/Blog/favicon.ico"><link rel="apple-touch-icon" href="/Blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/Blog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">杜绝使用 npm</h1><a id="logo" href="/Blog/.">zch233</a><p class="description">人到中年</p></div><div id="nav-menu"><a class="current" href="/Blog/."><i class="fa fa-home"> Home</i></a><a href="/Blog/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">杜绝使用 npm</h1><div class="post-meta">2022-02-13<span> | </span><span class="category"><a href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">管理器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#npm"><span class="toc-number">2.</span> <span class="toc-text">npm</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#NPM-%E7%9A%84%E6%80%9D%E8%B7%AF%E5%A4%A7%E6%A6%82%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%9A"><span class="toc-number">2.0.0.0.0.1.</span> <span class="toc-text">NPM 的思路大概是这样的：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E5%B1%95"><span class="toc-number">2.0.0.0.0.2.</span> <span class="toc-text">发展</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#yarn"><span class="toc-number">3.</span> <span class="toc-text">yarn</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-yarn"><span class="toc-number">3.0.1.</span> <span class="toc-text">安装 yarn</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pnpm%EF%BC%88performant-npm%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">pnpm（performant npm）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-pnpm"><span class="toc-number">4.0.1.</span> <span class="toc-text">安装 pnpm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%97%B6"><span class="toc-number">5.1.</span> <span class="toc-text">安装时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">包管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC"><span class="toc-number">5.3.1.</span> <span class="toc-text">依赖版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.2.</span> <span class="toc-text">目录结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monorepo"><span class="toc-number">5.4.</span> <span class="toc-text">monorepo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-yarn"><span class="toc-number">6.</span> <span class="toc-text">目前我们为什么使用 yarn</span></a></li></ol></div></div><div class="post-content"><h1 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h1><ul>
<li>npm，太慢了，总会有莫名的bug，需要删除 node_modules，在次安装以后才能解决。</li>
<li>cnpm，已经淘汰。</li>
<li>yarn &#x2F; yarnPnP，比 npm 快很多，比 npm 做了很多的优化，但是还存有和 npm 一样的其他问题。</li>
<li>pnpm，更快，且解决了 npm&#x2F;yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景。</li>
</ul>
<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>node 自带</p>
<blockquote>
<p>为什么 node 要选择 npm？<br>在远古时代，前端是通过网址来共享代码，比如你想使用 jQuery，那么你点击 jQuery 网站上提供的链接就可以下载 jQuery，放到自己的网站上使用。<br>但是当项目的依赖越来越多的时候，这是一件很麻烦的事情，去 jQuery 官网下载 jQuery，去 BootStrap 官网下载 BootStrap…等等。<br>程序员 <a target="_blank" rel="noopener" href="https://github.com/isaacs">Isaac Z. Schlueter</a> 给出一个解决方案：用一个工具把这些代码集中到一起来管理吧！毕竟懒才是程序员的第一生产力。</p>
</blockquote>
<h6 id="NPM-的思路大概是这样的："><a href="#NPM-的思路大概是这样的：" class="headerlink" title="NPM 的思路大概是这样的："></a>NPM 的思路大概是这样的：</h6><ul>
<li>买个服务器作为代码仓库（registry），在里面放所有需要被共享的代码</li>
<li>发邮件通知 jQuery、Bootstrap、Underscore 作者使用 npm publish 把代码提交到 registry 上，分别取名 jquery、bootstrap 和 underscore（注意大小写）</li>
<li>社区里的其他人如果想使用这些代码，就把 jquery、bootstrap 和 underscore 写到 package.json 里，然后运行 npm install ，npm 就会帮他们下载代码</li>
<li>下载完的代码出现在 node_modules 目录里，可以随意使用了。</li>
</ul>
<h6 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h6><ul>
<li>Isaaz 通知 jQuery 作者 John Resig，他会答应吗？这事儿不一定啊，对不对。</li>
<li>只有社区里的人都觉得 「npm 是个宝」的时候，John Resig 才会考虑使用 npm。</li>
<li>那么 npm 是怎么火的呢？</li>
<li>npm 的发展是跟 Node.js 的发展相辅相成的。</li>
<li>Node.js 是由一个在德国工作的美国程序员 Ryan Dahl 写的。他写了 Node.js，但是 Node.js 缺少一个包管理器，于是他和 npm 的作者一拍即合、抱团取暖，最终 Node.js 内置了 npm<em>（现在来看为什么 npm 这么烂，node 还要选择它，当时的 node 觉得自己 i&#x2F;o 很快，且当时的程序还没有这么复杂）</em>。后来的事情大家都知道，Node.js 火了。</li>
<li>所以说一门技术想要流行就得攀附、组合，NPM 全称 node package manager。（类似 LAMP，之前在编程历史中讲过）</li>
</ul>
<h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><h3 id="安装-yarn"><a href="#安装-yarn" class="headerlink" title="安装 yarn"></a>安装 yarn</h3><blockquote>
<p>首先<strong>不推荐</strong>使用 npm 安装<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40025890/why-wouldnt-i-use-npm-to-install-yarn">为什么？</a></p>
<ul>
<li>Yarn 团队认为 npm 不安全且不可靠，根据Yarn项目维护者的说法，通过npm安装Yarn<a target="_blank" rel="noopener" href="https://github.com/yarnpkg/yarn/issues/1082#issuecomment-254026649" title="“应该将纱线视为一个“应用程序”而不是一个“ npm软件包””">违反了项目目标</a>，可能会引起问题，并且通常比特定于平台的安装方法更糟糕。</li>
<li>一般不推荐通过 npm 安装 Yarn。使用 npm 安装 Yarn 是不确定的，包没有签名，唯一执行的完整性检查是基本的 SHA1 哈希，这在安装系统范围的应用程序时是一个安全风险。</li>
<li>通过 npm 运行 Yarn，它是一个单独的包管理器实用程序，可能会导致边缘问题（请参阅<a target="_blank" rel="noopener" href="https://github.com/yarnpkg/yarn/issues/2072" title="ENOENT 在运行 yarn 时试图要求 `uuid.js`">issue 2072</a>）</li>
<li>通过系统包管理器安装将 Yarn 与 npm 分离，允许您在没有 npm 的情况下运行 Yarn</li>
<li>系统包管理器通常会定期运行，保持 Yarn 更新</li>
<li>通过 npm 安装 Yarn 很<a target="_blank" rel="noopener" href="https://github.com/yarnpkg/yarn/issues/2077#issuecomment-265280075" title="Daniel15 对问题 #2077 的评论">慢</a></li>
</ul>
</blockquote>
<blockquote>
<p><strong>但是</strong>从 Yarn 2.x 开始，Yarn 团队改变了他们的建议，现在建议通过 npm 安装该工具。此建议围绕锁定每个项目使用的 Yarn 版本的优势。这使项目能够适应不同版本的 Yarn 的变化。</p>
</blockquote>
<h1 id="pnpm（performant-npm）"><a href="#pnpm（performant-npm）" class="headerlink" title="pnpm（performant npm）"></a>pnpm（performant npm）</h1><p><img src="/Blog/2022/02/13/essay/%E6%9D%9C%E7%BB%9D%E4%BD%BF%E7%94%A8npm/index/img.png"></p>
<h3 id="安装-pnpm"><a href="#安装-pnpm" class="headerlink" title="安装 pnpm"></a>安装 pnpm</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i -g pnpm</span><br></pre></td></tr></table></figure>

<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="安装时"><a href="#安装时" class="headerlink" title="安装时"></a>安装时</h2><p>执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:</p>
<ol>
<li>将依赖包的版本区间解析为某个具体的版本号</li>
<li>下载对应版本依赖的 tar 包到本地离线镜像（能够在无网环境下安装，npm 5+ 才抄袭过来）</li>
<li>将依赖从离线镜像解压到本地缓存</li>
<li>将依赖从缓存拷贝到当前目录的 node_modules 目录</li>
</ol>
<p>然后，对应的包就会到达项目的node_modules当中。</p>
<h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><p><img src="/Blog/2022/02/13/essay/%E6%9D%9C%E7%BB%9D%E4%BD%BF%E7%94%A8npm/index/img_1.png"></p>
<blockquote>
<p>很明显 npm 是最慢的。<br>为什么慢，因为 node_modules，文件小而多，磁盘 I&#x2F;O 的特别慢，而且重复下载的文件也会在有多。</p>
</blockquote>
<h2 id="包管理方式"><a href="#包管理方式" class="headerlink" title="包管理方式"></a>包管理方式</h2><h3 id="依赖版本"><a href="#依赖版本" class="headerlink" title="依赖版本"></a>依赖版本</h3><ul>
<li>npm包管理工具都是通过 package.json 中对各个依赖包的描述去下载对应的依赖包的。</li>
<li>但 package.json <strong>只能规定大版本号</strong>。这样就会导致每个时期下载的依赖包都是不一样的，很容易出现兼容性等各种问题。例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.2.6&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>字符 <code>^</code> 告诉 NPM 检查在 <code>3.X.X</code> 范围内是否有较新版本，如果有，则进行安装。类似地，<code>~</code> 字符只会出现在热修复程序或 <code>3.2.X</code> 上。</li>
<li>这样导致项目每次安装的时候版本不一致，可能引起一些相关错误。</li>
<li>而 yarn 率先发明了 lockfiles（已被 npm 5+ 抄袭）。</li>
<li>规定了具体每个依赖包的版本号和对应的下载路径，保证我们下次在重新安装依赖时，能跟上次一模一样。<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">package</span>-lock.json，npm 是 json 文件，方便看得懂</span><br><span class="line"><span class="string">&quot;vue&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;3.2.6&quot;</span>,   </span><br><span class="line">  <span class="string">&quot;resolved&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/vue/-/vue-3.2.6.tgz&quot;</span>,   <span class="regexp">//</span>下载路径</span><br><span class="line">  <span class="string">&quot;integrity&quot;</span>: <span class="string">&quot;sha512-Zlb3LMemQS3Xxa6xPsecu45bNjr1hxO8Bh5FUmE0Dr6Ot0znZBKiM47rK6O7FTcakxOnvVN+NTXWJF6u8ajpCQ==&quot;</span>,   </span><br><span class="line">  <span class="string">&quot;requires&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@vue/compiler-dom&quot;</span>: <span class="string">&quot;3.2.6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vue/runtime-dom&quot;</span>: <span class="string">&quot;3.2.6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vue/shared&quot;</span>: <span class="string">&quot;3.2.6&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>如果一个项目有 100 个依赖，并且这些依赖的依赖都有 lodash。</li>
<li>在 npm 中 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。所以这能不能优化呢？</li>
<li>而在 yarn 中会实行的是扁平结构（已被 npm 3+ 抄袭）。<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ① 假设项目依赖a,b,c三个模块，依赖树为:</span></span><br><span class="line"><span class="comment">#  +- a</span></span><br><span class="line"><span class="comment">#    +- react@15</span></span><br><span class="line"><span class="comment">#  +- b</span></span><br><span class="line"><span class="comment">#    +- react@16</span></span><br><span class="line"><span class="comment">#  +- c</span></span><br><span class="line"><span class="comment">#    +- react@16</span></span><br><span class="line"><span class="comment"># yarn安装时会按照项目被依赖的次数作为权重，将依赖提升(hoisting)，</span></span><br><span class="line"><span class="comment"># 安装后的node_modules结构为:</span></span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   ├── node_modules</span><br><span class="line">      │   │   └── react  <span class="comment"># @15</span></span><br><span class="line">      │   └── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>      ├── <span class="keyword">b</span></span><br><span class="line"><span class="keyword"></span>      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   └── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>      ├── c</span><br><span class="line">      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   └── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>      └── react  <span class="comment"># @16 被依赖了两次，所以进行提升</span></span><br></pre></td></tr></table></figure></li>
<li>这样一来，重复的包将会大量减少，但是由于“提升”，当你只安装一个依赖的时候，会发现 node_modules 下多了很多的你没有安装的目录（因为重复的被提升了），node_modules 目录将会变得很丑。</li>
<li><img src="/Blog/2022/02/13/essay/%E6%9D%9C%E7%BB%9D%E4%BD%BF%E7%94%A8npm/index/img_2.png"></li>
<li>Q：为什么不一起把 react15 也一起提升了？</li>
<li>A：因为 node_modules 不能有效地处理重复的包. 两个名称相同但是不同版本的包是不能在一个目录下共存的。<br>-而且这里还有一个<strong>潜在的问题</strong>，即：如果 A 依赖 B， B 依赖 C，由于提升了那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖，因此会出现这种非法访问的情况（其中也有因为Node没有包的概念的关系，我猜测可能和 js 是一门运行时的语言有关）。</li>
<li>接下来在看两种情况：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ② 现在假设在①的基础上，根项目依赖了react@15，对于项目自己的依赖肯定是要放在node_modules根目录的，</span></span><br><span class="line"><span class="comment"># 由于一个目录下不能存在同名目录，所以react@16没有的提升机会. </span></span><br><span class="line"><span class="comment"># 安装后node_moduels结构为</span></span><br><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   └── package.<span class="keyword">json </span><span class="comment"># react@15 提升</span></span><br><span class="line">      ├── <span class="keyword">b</span></span><br><span class="line"><span class="keyword"></span>      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   ├── node_modules</span><br><span class="line">      │   │   └── react  <span class="comment"># @16</span></span><br><span class="line">      │   └── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>      ├── c</span><br><span class="line">      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   ├── node_modules</span><br><span class="line">      │   │   └── react  <span class="comment"># @16</span></span><br><span class="line">      │   └── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>      └── react  <span class="comment"># @15</span></span><br><span class="line"><span class="comment"># 上面的结果可以看出，react@16出现了重复</span></span><br></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  .</span><br><span class="line">  └── node_modules</span><br><span class="line">      ├── a</span><br><span class="line">      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   ├── node_modules</span><br><span class="line">      │   │   └── react  <span class="comment"># @16</span></span><br><span class="line">      │   └── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>      ├── <span class="keyword">b</span></span><br><span class="line"><span class="keyword"></span>      │   ├── index.<span class="keyword">js</span></span><br><span class="line"><span class="keyword"></span>      │   ├── node_modules</span><br><span class="line">      │   │   └── react  <span class="comment"># @15</span></span><br><span class="line">      │   └── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>      └── react  <span class="comment"># @15 or 16?</span></span><br><span class="line"><span class="comment"># 答案是: 都有可能。取决于 a 和 b 在 package.json中的位置，如果 a 声明在前面，那么就是提升的就是 react@16，否则是react@15。</span></span><br></pre></td></tr></table></figure></li>
<li>所以这种扁平化结构存在的缺点有：一、依赖结构的<strong>不确定性</strong>。二：扁平化算法本身的<strong>复杂性很高</strong>，耗时较长。三：项目中仍然可以<strong>非法访问</strong>没有声明过依赖的包。四：在某些情况下没有很好的解决<strong>重复问题</strong>。</li>
<li>因此 yarn 又做出了改进，加入的 <strong>PnP（Plug’n’Play）</strong> 功能，1.12 版本开始默认包含，2.0 版本开始默认开启。</li>
<li>基本原理：Yarn 作为一个包管理器，它知道你的项目的依赖树. 那能不能让 Yarn 告诉 Node? 让它直接到某个目录去加载模块。这样即可以提高 Node 模块的查找效率，也可以减少 node_modules 文件的拷贝。</li>
<li>在 pnp 模式下，Yarn 不会创建 node_modules 目录，取而代之的是 <strong>.yarn 目录</strong>和 <strong>.pnp.js</strong>文件。</li>
<li><code>.pnp.js</code> 文件，这个文件包含了项目的依赖树信息，模块查找算法，也包含了模块查找器的 patch 代码(在 Node 环境，覆盖 Module._load 方法)，简单来说就是项目的npm模块解析规则。</li>
<li>.yarn 目录存放了项目中下载的所有依赖的zip包。</li>
<li><img src="/Blog/2022/02/13/essay/%E6%9D%9C%E7%BB%9D%E4%BD%BF%E7%94%A8npm/index/img_3.png"></li>
<li>使用 pnp 机制的以下优点：<ol>
<li>摆脱了 node_modules：<ul>
<li>时间上: 相比较在热缓存(hot cache)环境下运行yarn install节省 70%的时间。</li>
<li>空间上: pnp 模式下，所有 npm 模块都会存放在全局的缓存目录下，依赖树扁平化，避免拷贝和重复。</li>
</ul>
</li>
<li>提高模块加载效率，Node 为了查找模块，需要调用大量的 stat 和 readdir 系统调用。. pnp 通过 Yarn 获取或者模块信息，直接定位模块。</li>
<li>不再受限于 node_modules 同名模块不同版本不能在同一目录。</li>
</ol>
</li>
<li>使用 pnp 机制的以下缺点<ol>
<li>因为 node 依赖解析的目录 node_modules 没了，不能直接使用 node xxx.js。</li>
<li>由于还是不够成熟（2018.9面世），前端社区其他工具链支持度还不够，从官方看已有<a target="_blank" rel="noopener" href="https://yarnpkg.com/features/pnp#native-support">下列的工具有条件支持(某版本起或插件支持)</a>。</li>
</ol>
</li>
<li>但 pnpm 内部使用基于内容寻址的文件系统来存储磁盘上所有的文件，他只会安装一次，磁盘中只有一个地方写入（rails 也类似这样），后面再次使用都会直接使用 hardlink（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html">硬链接</a>），这种方法几乎就解决了上面的所有问题。</li>
<li>例如我们安装一个依赖：<code>pnpm init -y</code> &amp;&amp; <code>pnmp i react</code></li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── node_modules</span><br><span class="line">│    ├── <span class="string">.pnpm</span></span><br><span class="line">│    ├── react</span><br><span class="line">│    ├── <span class="string">.modules.yaml</span></span><br><span class="line">└── package.json</span><br><span class="line">└── pnpm-lock.yaml <span class="comment"># lockfiles</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如此整洁、干净，我们直接就看到了 react，但值得注意的是，这里仅仅只是一个软链接，那么它真正的位置在哪呢？</li>
<li>.pnpm 当中寻找：<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── node_modules</span><br><span class="line">      ├── .pnpm</span><br><span class="line">            ├ node_modules</span><br><span class="line">            ├ registry.npmjs.org+@js+tokens@<span class="number">4.0</span><span class="number">.0</span></span><br><span class="line">            ├ <span class="params">...</span><span class="params">...</span>.</span><br><span class="line">            ├ registry.npmjs.org+react@<span class="number">17.0</span><span class="number">.2</span></span><br><span class="line">                ├ node_modules</span><br><span class="line">                    ├ loose<span class="params">-envify</span> (软链接)</span><br><span class="line">                    ├ <span class="params">...</span> (软链接)</span><br><span class="line">                    ├ react</span><br><span class="line">                      ├ cjs</span><br><span class="line">                      ├ umd</span><br><span class="line">                      ├ <span class="params">...</span><span class="params">...</span></span><br></pre></td></tr></table></figure></li>
<li>好家伙！竟然在 <code>.pnpm/egistry.npmjs.org+react@17.0.2/node_modules/react</code> 下面找到了！同级其他的依赖也都是软链接。</li>
<li>再看看.pnpm，.pnpm目录下虽然呈现的是扁平的目录结构，但仔细想想，顺着软链接慢慢展开，其实就是嵌套的结构！</li>
<li>将包本身和依赖放在同一个node_module下面，与原生 Node 完全兼容，又能将 package 与相关的依赖很好地组织到一起，设计十分精妙，也解决了 yarn PnP 没有 node_modules 的问题。</li>
<li>这么好的东西为什么没有人用呢？<ul>
<li>兼容问题，像 hard link 和 symlink 这种方式在所有的系统上都是兼容的吗？实际上 hard link 在主流系统上(Unix&#x2F;Win)使用都是没有问题的，但是 symlink 即软连接的方式可能会在 windows 存在一些兼容的问题，但是针对这个问题，pnpm 也提供了对应的解决方案：在 win 系统上使用一个叫做 junctions 的特性来替代软连接，这个方案在 win 上的兼容性要好于 symlink。</li>
<li>或许你也会好奇为啥 pnpm 要使用 hard links 而不是全都用 symlink 来去实现。</li>
<li>实际上存在 store 目录里面的依赖也是可以通过软连接去找到的，nodejs 本身有提供一个叫做 –preserve-symlinks 的参数来支持 symlink，但实际上这个参数实际上对于 symlink 的支持并不好导致作者放弃了该方案从而采用 hard links 的方式。<a target="_blank" rel="noopener" href="https://github.com/nodejs/node-eps/issues/46">具体可以参考该 issue</a>。</li>
<li><img src="/Blog/2022/02/13/essay/%E6%9D%9C%E7%BB%9D%E4%BD%BF%E7%94%A8npm/index/img_4.png"></li>
</ul>
</li>
</ul>
<h2 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h2><ul>
<li>只有 pnpm 支持。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/350317373">npm(npm 7+ 抄袭)&#x2F;yarn workspace</a></li>
<li>随着前端工程的日益复杂，越来越多的项目开始使用 monorepo。之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的packages目录下，那么一个子项目就代表一个package。如果你之前没接触过 monorepo 的概念，建议仔细看看这篇文章(<a href="https://link.zhihu.com/?target=https://www.perforce.com/blog/vcs/what-monorepo">https://www.perforce.com/blog/vcs/what-monorepo</a>)以及开源的 monorepo 管理工具<code>lerna</code>(<a href="https://link.zhihu.com/?target=https://github.com/lerna/lerna%23readme">https://github.com/lerna/lerna#readme</a>)，项目目录结构可以参考一下 <code>babel 仓库</code>(<a href="https://link.zhihu.com/?target=https://github.com/babel/babel">https://github.com/babel/babel</a>)。</li>
<li>pnpm 体现在各个子命令的功能上，比如在根目录下 <code>pnpm add A -r</code>，那么所有的 package 中都会被添加 A 这个依赖，当然也支持 –filter 字段来对 package 进行过滤。</li>
</ul>
<h1 id="目前我们为什么使用-yarn"><a href="#目前我们为什么使用-yarn" class="headerlink" title="目前我们为什么使用 yarn"></a>目前我们为什么使用 yarn</h1><ul>
<li>因为 npm 太慢了。</li>
<li>从目前主流的开源项目来看，几乎没有使用 npm 的仓库，一般都是 yarn。</li>
<li>团队内需要统一，如果不一致可能会出现依赖问题(npm 和 yarn 的 lock 文件不同)。</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/Blog/2022/03/12/javascript/%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/index/">函数全解</a><a class="next" href="/Blog/2022/02/02/node_js/2021-Node%20%E7%9A%84%E6%96%B0%E5%8F%98%E5%8C%96/index/">2021 Node 的新变化</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'e4a44394ea630529848c',
  clientSecret: '884b4deb2d55fbcc63921e12f73b58e944efa110',
  repo: 'Blog',
  owner: 'zch233',
  admin: ['zch233'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="./about/" title="About"><img class="nofancybox" src="/Blog/img/avatar.png"/></a><p>coder.</p><a class="info-icon" href="zch2333333@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zch233" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Lisp/">Lisp</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Rails/">Rails</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/SCSS/">SCSS</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">chrome调试技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/daisy/">daisy</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/relearnFE/">relearnFE</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95/">准备面试</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E7%96%91/">日常杂疑</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E8%B6%A3%E9%97%BB/">趣闻</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/08/27/essay/AI%E8%81%8A%E5%A4%A9prompt/index/">AI聊天prompt</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/17/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9AJS-TS/index/">TypeScript全解：JS&TS</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/16/typescript/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/index/">React 泛型组件是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：类型体操（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：类型体操（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：class（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：class（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：泛型编程（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：泛型编程（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/11/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：深入对象与函数（下）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.jianshu.com/u/4b4c7aec223d" title="littleyu" target="_blank">littleyu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/Blog/." rel="nofollow">zch233.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/Blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/Blog/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/Blog/css/search.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/Blog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/Blog/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/Blog/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/Blog/js/smartresize.js?v=1.0.0"></script></div></body></html>