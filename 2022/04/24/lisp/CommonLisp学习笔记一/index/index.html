<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>CommonLisp学习笔记一 | zch233</title><link rel="stylesheet" type="text/css" href="/Blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/Blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/Blog/favicon.ico"><link rel="apple-touch-icon" href="/Blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/Blog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CommonLisp学习笔记一</h1><a id="logo" href="/Blog/.">zch233</a><p class="description">人到中年</p></div><div id="nav-menu"><a class="current" href="/Blog/."><i class="fa fa-home"> Home</i></a><a href="/Blog/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CommonLisp学习笔记一</h1><div class="post-meta">2022-04-24<span> | </span><span class="category"><a href="/Blog/categories/Lisp/">Lisp</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F-form"><span class="toc-number">1.</span> <span class="toc-text">范式(form)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%82%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">求值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">3.</span> <span class="toc-text">数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">表的操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">真值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">7.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">8.</span> <span class="toc-text">输入和输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">9.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%96%E7%BC%96%E7%A8%8B%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">函数化编程法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">12.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">函数作为对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.</span> <span class="toc-text">类型</span></a></li></ol></div></div><div class="post-content"><h1 id="范式-form"><a href="#范式-form" class="headerlink" title="范式(form)"></a>范式(form)</h1><p>任何 Lisp系统都包含一个叫做顶层(toplevel)的交互式前端，你在顶层中输入Lisp表达式,系统打印它们的值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>系统会打印它的值,跟着另一个提示符,表示它在等待更多的输入. 在这种情况下,打印出来的值和我们输入的一样. 象1这样的数叫做自身求值的</p>
<p>当我们输入一个需要做些求值工作的表达式时</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在表达式(+ 2 3)中,+叫做操作符,数2和3叫做变元<br>Lisp中我们把+写 在最前面,后面跟着变元,整个表达式被一对括号围住:(+ 2 3). 因为操作 符在前,这叫做<strong>前缀表示法</strong><br>一开始这样写表达式有点怪,我们想把三个数加起来,用通常的表示法我们要写+两次 <code>2 + 3 + 4</code>,而在Lisp中我们仅需增加一个变元: <code>(+ 2 3 4)</code></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">/</span> (<span class="name">-</span> <span class="number">7</span> <span class="number">1</span>) (<span class="name">-</span> <span class="number">4</span> <span class="number">2</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h1><p>在Lisp中,+是一个函数,形如(+ 2 3)的表达式是函数调用. 当Lisp对函数调用求 值时,它做这样两步:</p>
<ol>
<li>首先变元从左至右被求值. 在此例中,每个变元求值到自身,所以变元的值 分别是2和3.</li>
<li>变元的值传给以操作符命名的函数. 在此例中,即+函数,它返回5.</li>
</ol>
<p>如果任何变元本身是函数调用,它们按上述规则求值. 这是对(&#x2F; (- 7 1) (- 4 2))求值时发生的情况:</p>
<ol>
<li>Lisp计算(- 7 1): 7求值为7,1求值为1. 它们被传给函数-,它返回6.</li>
<li>Lisp计算(- 4 2): 4求值为4,2求值为2. 它们被传给函数-,它返回2.</li>
<li>6和2的值传给函数&#x2F;,它返回3.</li>
</ol>
<blockquote>
<p>并不是所有的Lisp操作符都是函数,但大多数都是. 而函数总是按这种方式求值 的. 变元从左至右被求值,它们的值被传给函数,函数返回整个表达式的值. 这叫做Common Lisp的求值规则.一个不遵守上述规则的操作符是quote</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">quote</span> (+ <span class="number">3</span> <span class="number">5</span>))</span><br><span class="line">(<span class="name">+</span> <span class="number">3</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>为了方便,Common Lisp定义’作为quote的简记法. 通过在任何表达式前面加上’ 你能获得与调用quote同样的效果:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x27;(+ <span class="number">3</span> <span class="number">5</span>)</span><br><span class="line">(<span class="name">+</span> <span class="number">3</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>用简记法比用quote普遍得多. Lisp提供quote作为一种保护表达式以防被求值的手段</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 从麻烦中解脱出来 如果你输入了一些Lisp不能理解的东西,它会打印一条出错信息并把你带到一个 叫中断循环(break loop)的顶层中去. 中断循环给了有经验的程序员弄清出错原 因的机会,不过一开始你唯一需要知道的事是如何从中断循环中出来. 如何返回 顶层取决于你用的Lisp环境. 在这个假设的环境里,用:abort出来:</span></span><br><span class="line">&gt; (<span class="name">/</span> <span class="number">1</span> <span class="number">0</span>)</span><br><span class="line">Error: Division by zero.</span><br><span class="line">       Options: :abort, :backtrace</span><br><span class="line">&gt;&gt; :abort</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>Lisp提供在其它语言中找得到的数据类型，一是整数,另一种和其它语言一样有的是字符串,整数 和字符串都求值到自身. 另两种我们不常在其它语言中发现的是符号和表. 符号是单词. 通常它们被转换成大写,不管你如何输入</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x27;Artichoke</span><br><span class="line">ARTICHOKE</span><br></pre></td></tr></table></figure>
<p>符号(通常)不求值为自身,因此如果你想引用一个符号,请象上面那样用<code>&#39;</code>引用它. 表表示为被括号包围的零个或多个元素. 元素可以是任何类型,包括表. 你必须引用表,否则Lisp会以为它是函数调用:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x27;(my <span class="number">3</span> <span class="string">&quot;Sons&quot;</span>)</span><br><span class="line">(<span class="name">MY</span> <span class="number">3</span> <span class="string">&quot;Sons&quot;</span>)</span><br><span class="line">&gt; &#x27;(the list (a b c) has <span class="number">3</span> elements)</span><br><span class="line">(<span class="name">THE</span> LIST (<span class="name">A</span> B C) HAS <span class="number">3</span> ELEMENTS)</span><br></pre></td></tr></table></figure>

<p>请注意一个引号保护整个表达式,包括里面的表达式. 你可以调用list来构造表. 因为list是一个函数,它的变元被求值. 这是+调用在 list调用里的例子:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">list</span> &#x27;my (<span class="name">+</span> <span class="number">2</span> <span class="number">1</span>) <span class="string">&quot;Sons&quot;</span>)</span><br><span class="line">(<span class="name">MY</span> <span class="number">3</span> <span class="string">&quot;Sons&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在我们处于欣赏Lisp最非同寻常特征之一的位置上. Lisp程序表达为表.</p>
</blockquote>
<p>Lisp程序表达为表. 如果变元的机动性和优雅性没能说服你Lisp记号是一种有价值的工具,这点应该能使你信服. 这意味着<strong>Lisp程序可以生成Lisp代码</strong>. Lisp程序员能(而且经常)为自己编写能写程序的程序.<br>在现阶段理解表达式和表的关系也是很重 要的,而不是被它们弄糊涂. 这就是为何我们使用quote. 如果一个表被引用了, 求值返回它本身; 如果没有被引用,它被认为是代码,求值返回它的值:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">list</span> &#x27;(+ <span class="number">2</span> <span class="number">1</span>) (<span class="name">+</span> <span class="number">2</span> <span class="number">1</span>))</span><br><span class="line">((<span class="name">+</span> <span class="number">2</span> <span class="number">1</span>) <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>此处第一个变元被引用了,所以生成了一个表. 第二个变元没有被引用,视之为函 数调用,得出一个数字. 在Common Lisp中有两种方法表示空表. 你可用一对不包含任何东西的括号来表 示空表,或用符号nil来表示它. 你用哪种方法表示空表都没有关系,不过它会被 显示成nil:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ()</span><br><span class="line">NIL</span><br><span class="line">&gt; <span class="literal">nil</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>

<h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><p>函数cons构造表. 如果它的第二个变元是表,它返回一个新表,新表的第一个元素 就是第一个变元:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">cons</span> &#x27;a &#x27;(b c d))</span><br><span class="line">(<span class="name">A</span> B C D)</span><br></pre></td></tr></table></figure>

<p>我们可以通过把新元素cons到空表来构造新表. 我们在上一节见到的list函数只不过是一个把几样东西cons到nil上去的方便办法:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">cons</span> &#x27;a (<span class="name">cons</span> &#x27;b <span class="literal">nil</span>)) // &gt; (<span class="name">cons</span> &#x27;a &#x27;b)</span><br><span class="line">(<span class="name">A</span> B) // (<span class="name">A</span> . B)</span><br><span class="line">&gt; (<span class="name">list</span> &#x27;a &#x27;b)</span><br><span class="line">(<span class="name">A</span> B)</span><br></pre></td></tr></table></figure>

<p>基本的提取表中元素的函数是car和cdr表的car就是它的第一个元素,而 cdr是第一个元素后面的所有东西:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">car</span> &#x27;(a b c))</span><br><span class="line">A</span><br><span class="line">&gt; (<span class="name">cdr</span> &#x27;(a b c))</span><br><span class="line">(<span class="name">B</span> C)</span><br><span class="line">&gt; (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">cdr</span> &#x27;(a b c d))))</span><br><span class="line">C</span><br><span class="line"><span class="comment">;; 但是,你可以用third更容易地做同样的事:</span></span><br><span class="line">&gt; (<span class="name">third</span> &#x27;(a b c d))</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h1 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h1><p>符号t是Common Lisp中表示真的缺省值. 就象nil,t求值到自身. 函数listp返回 真如果它的变元是一个表:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">listp</span> &#x27;(a b c))</span><br><span class="line">T</span><br></pre></td></tr></table></figure>

<p><strong>一个函数叫做断言如果它的返回值被解释成真或假</strong>. Common Lisp的断言的名字通常以p结尾. 假在Common Lisp中用nil(空表)来表示. 如果我们传给listp的变元不是表,它返回nil:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">listp</span> <span class="number">27</span>)</span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>因为nil扮演两个角色,函数null返回真如果它的变元是空表:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">null</span> <span class="literal">nil</span>)</span><br><span class="line">T</span><br></pre></td></tr></table></figure>
<p>而函数not返回真如果它的变元是假:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">not</span> <span class="literal">nil</span>)</span><br><span class="line">T</span><br></pre></td></tr></table></figure>
<p>它们完全做的是同样的事情. 要if是Common Lisp中最简单的条件语句. 它一般接受三个变元:一个测试表达式, 一个then表达式和一个else表达式</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">if</span> (<span class="name">listp</span> &#x27;(a b c))</span><br><span class="line">      (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">      (<span class="name">+</span> <span class="number">5</span> <span class="number">6</span>)</span><br><span class="line">    )</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; (<span class="name">if</span> (<span class="name">listp</span> <span class="number">27</span>)</span><br><span class="line">      (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">      (<span class="name">+</span> <span class="number">5</span> <span class="number">6</span>)</span><br><span class="line">   )</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>就象quote,if是特殊操作符. 它不能用函数来实现,因为函数调用的变元总是要 求值的,而if的特点是只有最后两个变元中的一个被求值. if的最后一个变元是可选的. 如果你省略它,它缺省为nil:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">if</span> (<span class="name">listp</span> <span class="number">27</span>) </span><br><span class="line">      (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>
<p>虽然t是真的缺省表示,任何不是nil的东西在逻辑上下文中被认为是真:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">if</span> <span class="number">27</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>逻辑操作符and和or就象条件语句. 两者都接受任意数目的变元,但只求值能够确定返回值的数目的变元. 如果所有的变元都是真(不是nil),那么and返回最后变元的值:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">and</span> <span class="literal">t</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>但如果其中一个变元是假,所有它后面的变元都不求值了. or也类似,只要它碰到一个是真的变元就继续求值了. <strong>这两个操作符是宏</strong>. 就象特殊操作符,宏可以规避通常的求值规则</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>你可以用defun来定义新的函数. 它通常接受三个以上变元:一个名字,一列参数, 和组成函数体的一个或多个表达式. 这是我们定义third的一种可能:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">defun</span> our-third (<span class="name">x</span>)</span><br><span class="line">    (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">cdr</span> x))))</span><br><span class="line">OUR-THIRD</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">our-third</span> &#x27;(a b c d))</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">defun</span> sum-greater (<span class="name">x</span> y z)</span><br><span class="line">    (<span class="name">&gt;</span> (<span class="name">+</span> x y) z))</span><br><span class="line">SUM-GREATER</span><br><span class="line">&gt; (<span class="name">sum-greater</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span>)</span><br><span class="line">T</span><br></pre></td></tr></table></figure>

<p>Lisp对程序,过程或函数不加区别. 函数做了所有的事情(事实上构成了语言本身 的大部分). 你可以认为你的函数中的一个是主函数,但通常你能在顶层里调用任 何一个函数. 这意味着,当你写程序的时候,你能一小段一小段地测试它们.</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>我们在上一节中定义的函数还调用了其它函数为自己服务. 比如sum-greater调 用了+和&gt;. <strong>函数可以调用任何函数,包括它本身</strong>. 自己调用自己的函数是递归的.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> our-member (<span class="name">obj</span> lst)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span> lst)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name">if</span> (<span class="name">eql</span> (<span class="name">car</span> lst) obj)</span><br><span class="line">          lst</span><br><span class="line">          (<span class="name">our-member</span> obj (<span class="name">cdr</span> lst)))))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">our-member</span> &#x27;b &#x27;(a b c))</span><br><span class="line">(<span class="name">B</span> C)</span><br><span class="line">&gt; (<span class="name">our-member</span> &#x27;z &#x27;(a b c))</span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>

<h1 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h1><p>到目前为止,我们一直在利用顶层暗中使用i&#x2F;o. 对实际的交互式的程序,这可能还不够.<br>我们看一些输入输出函数. Common Lisp中最一般的输出函数是format. 它接受两个以上变元:第一个表示输出到哪儿,第二个是字符串模板,剩下的变元通常是对象,它们的打印表示 (printed representation)将被插入到模板中去. 这是个典型的例子:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~A plus ~A equals ~A.~%&quot;</span> <span class="number">2</span> <span class="number">3</span> (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line"><span class="number">2</span> plus <span class="number">3</span> equals <span class="number">5</span>.</span><br><span class="line">NIL</span><br></pre></td></tr></table></figure>

<p>注意两样东西打印在这儿. 第一行是format打印的. 第二行是format调用的返回值<br>在它里面,每个  A*表示一个将被填充的位置, 而 %表示新行符. 这些位置依次被后面的变元的值填充.<br>标准的输入函数是read. 当没有变元时,它从缺省的地方–通常是顶层–读入. 下面这个函数提示用户输入,然后返回任何输入的东西:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> askem (<span class="name">string</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~A&quot;</span> string)</span><br><span class="line">  (<span class="name">read</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 它运行如下:</span></span><br><span class="line">&gt; (<span class="name">askem</span> <span class="string">&quot;How old are you? &quot;</span>)</span><br><span class="line">How old are you? <span class="number">29</span></span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure>

<p>请记住read会永远等在那儿直到你输入什么东西并(通常要)敲入回车. 因此调用 read而不打印明确的提示信息是不明智的,否则你的程序会给人以已经死掉的印象,但实际上它在等待输入.<br>第二个要了解read的是它非常强大:它是一个完整的Lisp语法分析器. 它<strong>并不是读入字符再把它们当作字符串返回</strong>. 它分析所读到的东西,并返回所产生的Lisp 对象.</p>
<p>在上例中, 它返回一个数. askem虽然很短,<strong>但它展示了一些我们以前在函数定义中没有看到的内容</strong>. 它的函数体包含多个表达式. 函数体可以包含任意多个表达式,当函数被调用时,它们依次被求值,函数会返回最后一个表达式的值. 在以前的章节中,我们坚持所谓的&#96;&#96;纯粹’’的Lisp–即没有副作用的Lisp. <strong>副作用是指作为表达式求值的后果改变了外部世界的状态</strong>. 当我们对一个纯粹的Lisp 表达式,例如(+ 1 2)求值,没有出现副作用;它仅返回一个值. 但当我们调用 format,它不仅返回值,还打印了一些东西. <strong>这是一种副作用</strong>.</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>局部变量</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">let</span> ((<span class="name">x</span> <span class="number">1</span>) (<span class="name">y</span> <span class="number">2</span>))</span><br><span class="line">    (<span class="name">+</span> x y))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>一个let表达式有两部分. 第一部分是一列创造新变量的指令,每个形如(变量 表达式).<br>最后一个表达式的值作为let的值被返回.</p>
<p>下面是一个使用let 的更具选择性的askem的版本:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> ask-number ()</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;Please enter a number. &quot;</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">read</span>)))</span><br><span class="line">    (<span class="name">if</span> (<span class="name">numberp</span> val)</span><br><span class="line">        val</span><br><span class="line">        (<span class="name">ask-number</span>))))</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">ask-number</span>)</span><br><span class="line">Please enter a number. a</span><br><span class="line">Please enter a number. (<span class="name">ho</span> hum)</span><br><span class="line">Please enter a number. <span class="number">52</span></span><br><span class="line"><span class="number">52</span></span><br></pre></td></tr></table></figure>

<p>构造全局变量(习惯上全局变量的名字以星号开始和结束)</p>
<p>通过传给defparameter一个符号和一个值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">defparameter</span> *glob* <span class="number">99</span>)</span><br><span class="line">*GLOB*</span><br></pre></td></tr></table></figure>
<p>还可以用defconstant定义全局常数</p>
<figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defconstant</span> limit (<span class="name"><span class="built_in">+</span></span> *glob* <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>判断当前是否存在全局变量或常数的名字,请用boundp</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; (boundp &#x27;<span class="emphasis">*glob*</span>)</span></span><br><span class="line">T</span><br></pre></td></tr></table></figure>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>Common Lisp中最普通的赋值操作符是setf. 我们可以用它对全局或局部变量进 行赋值:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">setf</span> *glob* <span class="number">98</span>)</span><br><span class="line"><span class="number">98</span></span><br><span class="line">&gt; (<span class="name">let</span> ((<span class="name">n</span> <span class="number">10</span>))</span><br><span class="line">    (<span class="name">setf</span> n <span class="number">2</span>)</span><br><span class="line">    n)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果第一个自变量不是局部变量的名字,它被认为是全局变量:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">setf</span> x (<span class="name">list</span> &#x27;a &#x27;b &#x27;c))</span><br><span class="line">(<span class="name">A</span> B C)</span><br></pre></td></tr></table></figure>
<p>即你可以通过赋值隐含地新建全局变量.不过在源文件中明确地使用 defparameter是较好的风格.<br>你能做的远不止给变量赋值. setf的第一个自变量不但可以是变量名,还可以是 表达式. 在这种情况下,第二个自变量的值被插入到第一个所涉及到的位置:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">setf</span> (<span class="name">car</span> x) &#x27;n) </span><br><span class="line">N</span><br><span class="line">&gt; x</span><br><span class="line">(<span class="name">N</span> B C)</span><br></pre></td></tr></table></figure>
<p>setf的第一个自变量几乎可以是任何涉及特定位置的表达式. 所有这样的操作符在 附录D中都被标记为&#96;&#96;settable’’. 你可以给setf偶数个自变量. 形如</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setf</span> a b </span><br><span class="line">      c d </span><br><span class="line">      e f)</span><br></pre></td></tr></table></figure>
<p>的表达式相当于连续三个单独的setf调用:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setf</span> a b)</span><br><span class="line">(<span class="name">setf</span> c d)</span><br><span class="line">(<span class="name">setf</span> e f)</span><br></pre></td></tr></table></figure>
<h1 id="函数化编程法"><a href="#函数化编程法" class="headerlink" title="函数化编程法"></a>函数化编程法</h1><p>函数化编程法的意思是编写通过返回值来工作的程序,而不是修改什么东西.</p>
<p>它是 Lisp中占支配地位的范例. 大多数Lisp内置函数被调用是为了得到它们的返回值, 而不是它们的副作用.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">setf</span> lst &#x27;(c a r a t))</span><br><span class="line">(<span class="name">C</span> A R A T)</span><br><span class="line">&gt; (<span class="name">remove</span> &#x27;a lst)</span><br><span class="line">(<span class="name">C</span> R T)</span><br></pre></td></tr></table></figure>
<p>为什么不说remove从表中删除一个对象? 因为这不是它所做的事情. 原来的表没 有被改变:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; lst</span><br><span class="line">(<span class="name">C</span> A R A T)</span><br></pre></td></tr></table></figure>
<p>那么如果你真想从表中删掉一些元素怎么办? 在Lisp中,你通常这样做类似的事 情:把表传给某个函数,然后用setf来处理返回值. 为了把所有的a从表x中删掉, 我们这样做:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setf</span> x (<span class="name">remove</span> &#x27;a x))</span><br></pre></td></tr></table></figure>
<p>函数化编程法本质上意味着避免使用诸如setf的函数.<br>完全不利用副作用是有困难的. 但随着学习的深入,你会惊讶地发现真正需要副 作用的地方极少. 你使用副作用越少,你也就越进步.</p>
<blockquote>
<p>函数化编程最重要的优点之一是它允许交互式测试. 在纯粹的函数化代码中,当你写函数的时候就可以测试它们. 如果它返回期望的值,你可以肯定它是正确的.</p>
</blockquote>
<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>当我们想做一些重复的事情时,用迭代比用递归更自然些.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> show-squares (<span class="name">start</span> end)</span><br><span class="line">  (<span class="name">do</span> ((<span class="name">i</span> start (<span class="name">+</span> i <span class="number">1</span>)))</span><br><span class="line">      ((<span class="name">&gt;</span> i end) &#x27;done)</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~A ~A~%&quot;</span> i (<span class="name">*</span> i i))))</span><br></pre></td></tr></table></figure>
<p>打印从start到end之间的整数的平方:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">show-squares</span> <span class="number">2</span> <span class="number">5</span>)</span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span> <span class="number">16</span></span><br><span class="line"><span class="number">5</span> <span class="number">25</span></span><br><span class="line">DONE</span><br></pre></td></tr></table></figure>

<p>do宏是Common Lisp中最基本的迭代操作符. 就象let,do也会产生变量,它的第一 个自变量是关于变量规格的表. 表中的每个元素具有如下形式: <strong>(variable initial update)</strong></p>
<p>其中variable是符号,而initial和update是表达式. 一开始每个变量会被赋予相 应的initial的值;在迭代的时候它会被赋予相应的update的值.</p>
<p>作为对比,这是递归版本的show-squares:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> show-squares (<span class="name">i</span> end)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> i end)</span><br><span class="line">      &#x27;done</span><br><span class="line">      (<span class="name">progn</span></span><br><span class="line">        (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~A ~A~%&quot;</span> i (<span class="name">*</span> i i))</span><br><span class="line">        (<span class="name">show-squares</span> (<span class="name">+</span> i <span class="number">1</span>) end))))</span><br></pre></td></tr></table></figure>

<p>此函数中的唯一新面孔是progn. 它接受任意数量的表达式,对它们依次求值,然后返回最后一个的值.</p>
<p>对一些特殊情况Common Lisp有更简单的迭代操作符. 比如,为了遍历表的所有元素,你更可能用dolist. 这个函数返回表的长度</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">dolist</span> (<span class="name">n</span> &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>))</span><br><span class="line">   (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~% Number: ~d Square: ~d&quot;</span> n (<span class="name">*</span> n n))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Number: <span class="number">1</span> Square: <span class="number">1</span></span><br><span class="line">Number: <span class="number">2</span> Square: <span class="number">4</span></span><br><span class="line">Number: <span class="number">3</span> Square: <span class="number">9</span></span><br><span class="line">Number: <span class="number">4</span> Square: <span class="number">16</span></span><br><span class="line">Number: <span class="number">5</span> Square: <span class="number">25</span></span><br><span class="line">Number: <span class="number">6</span> Square: <span class="number">36</span></span><br><span class="line">Number: <span class="number">7</span> Square: <span class="number">49</span></span><br><span class="line">Number: <span class="number">8</span> Square: <span class="number">64</span></span><br><span class="line">Number: <span class="number">9</span> Square: <span class="number">81</span></span><br></pre></td></tr></table></figure>

<h1 id="函数作为对象"><a href="#函数作为对象" class="headerlink" title="函数作为对象"></a>函数作为对象</h1><p>函数在Lisp中就象符号,字符串和表一样,是常规的对象. 如果我们给function一个函数的名字,它会返回相关的对象. 就象quote,function是特殊操作符,因此我们不必引用自变量:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">function</span> +)</span><br><span class="line">#&lt;Compiled-Function + <span class="number">17</span>BA4E&gt;</span><br></pre></td></tr></table></figure>
<p>这个模样很奇怪的返回值是函数在典型Common Lisp实现中可能的显示方式. 到目前为止我们涉及到的对象具有这样的特点:Lisp显示它们与我们输入的模样是一致的. 此惯例不适合函数.</p>
<p>我们用’作为quote的简记法,我们可以用#’作为function的简写:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="comment">#&#x27;+</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;Compiled-Function + 17BA4E&gt;</span></span><br></pre></td></tr></table></figure>
<p>此简记法叫做sharp-quote. 就象其它的对象,函数可以作为自变量传递.<br>一个接受函数作为自变量的是 apply. 它接受一个函数和一列自变量,并返回那个函数应用这些自变量后的结果:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">apply</span> #&#x27;+ &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>它能接受任意数目的自变量,只要最后一个是表:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">apply</span> #&#x27;+ <span class="number">1</span> <span class="number">2</span> &#x27;(<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>函数funcall能做同样的事情,不过它不需要把自变量放在表中:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">funcall</span> #&#x27;+ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>宏defun创造一个函数并给它一个名字. 但函数并不是必须需要名字,因此我们也不需要用defun来定义它们. 就象其它Lisp对象一样,我们可以直接引用函数.<br>为了直接引用一个整数,我们用一列数字;为了直接引用函数,我们用所谓的 lambda表达式.<br>一个lambda表达式是包含以下元素的表:符号lambda,一列参数, 然后是零个或多个表达式组成的函数体. 这个lambda表达式代表接受两个数并返回它们之和的函数:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lambda</span> (<span class="name">x</span> y) </span><br><span class="line">  (<span class="name">+</span> x y))</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ((<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">+</span> x <span class="number">100</span>)) <span class="number">1</span>)</span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure>
<p>而通过在lamda表达式之前附加#’,我们得到了相应的函数:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">funcall</span> #&#x27;(lambda (x) (+ x <span class="number">100</span>))</span><br><span class="line">           <span class="number">1</span>)</span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>lambda是什么? lambda表达式中的lambda不是操作符. 它仅是个符号. 它在早期的Lisp方言里有一种作用:函数的内部形态是表,因此区别函数和普通表的唯一办法是查看第一个元素是否是符号lambda. 在Common Lisp中你能把函数表示为表,但它们在内部被表示成独特的函数对象. 因此lambda不再是必需的. 如果要求把函数<br><code>(lambda (x) (+ x 100))</code><br>表示成<br><code>((x) (+ x 100))</code><br>也没有什么矛盾,但Lisp程序员已经习惯了函数以符号lambda开始,因此Common Lisp保留了此传统.</p>
</blockquote>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>Lisp用非同寻常的灵活手段来处理类型. 在许多语言中,变量是有类型的,你得指 定变量的类型才能使用它. 在Common Lisp中,值具有类型,而不是变量.</p>
<p>你可以假想每个对象都贴了指明它的类型的标签. 这种方法叫做显示类型. 你不需要去声明变量的类型,因为变量可以装任何类型的对象.</p>
<p>数<code>27</code>是类型fixnum,integer,rational,real,number,atom,和t,以一般 性的增长为序. (Numeric类型在第9章中讨论)<strong>类型t是所有类型的超集,因此任何对象都是类型t</strong>.</p>
<p>函数typep接受一个对象和一个类型说明符,如果对象是那种类型就返回真:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">typep</span> <span class="number">27</span> &#x27;integer)</span><br><span class="line">T</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ol>
<li>Lisp是交互式语言. 如果你在顶层输入表达式,Lisp会打印它的值.</li>
<li>Lisp程序由表达式组成. 表达式可以是一个原子,或是一个表, 表的第一 个元素是操作符,后面跟着零个或多个自变量. 前缀表达式意味着操作符可接受任意多个自变量.</li>
<li>Common Lisp函数调用的求值规则:从左至右对自变量求值,然后把这些值传给由操作符表示的函数. quote有它自己的求值规则:它原封不动地返回自变量.</li>
<li>除了通常的数据类型,Lisp还有符号和表. 由于Lisp程序由表组成,很容易编写能写程序的程序.</li>
<li>三个基本的表处理函数是cons:它创造一个表;car:它返回表的头一个元素; cdr:它返回第一个元素之后的所有东西.</li>
<li>在Common Lisp里, t表示真,nil表示伪. 在逻辑上下文中,除了nil之外的任何东西都算作真. 基本的条件语句是if. and和or操作符就象条件语句.</li>
<li>Lisp主要是由函数构成的. 你可用defun来定义新的函数.</li>
<li>调用自己的函数是递归的. 递归函数应该被认为是一个过程而不是机器.</li>
<li>括号不是个问题,因为程序员利用缩进来读写Lisp.</li>
<li>基本的i&#x2F;o函数是read:它包含了完整的Lisp语法分析器,和format:它基于模板产生输出.</li>
<li>你可以用let创造新的局部变量,用defparameter创造新的全局变量.</li>
<li>赋值操作符是setf. 它的第一个自变量可以是表达式.</li>
<li>函数化编程法–它意味着避免副作用–是Lisp中占支配地位的范例.</li>
<li>基本的循环操作符是do.</li>
<li>函数是常规的Lisp对象. 它们可以作为自变量被传递,可以表示成lambda 表达式.</li>
<li>值有类型,而变量没有类型</li>
</ol>
<p>练习</p>
<ol>
<li>解释以下表达式求值后的结果:<ul>
<li>a. (+ (- 5 1) (+ 3 7))</li>
<li>b. (list 1 (+ 2 3))</li>
</ul>
</li>
<li>给出3种不同的能返回(a b c)的cons表达式</li>
<li>用car和cdr定义一个函数,它返回表的第四个元素.</li>
<li>定义一个函数,它接受两个自变量,返回两个中较大的一个.</li>
<li>这些函数做了什么? <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> enigma (<span class="name">x</span>)</span><br><span class="line">     (<span class="name">and</span> (<span class="name">not</span> (<span class="name">null</span> x))</span><br><span class="line">          (<span class="name">or</span> (<span class="name">null</span> (<span class="name">car</span> x))</span><br><span class="line">              (<span class="name">enigma</span> (<span class="name">cdr</span> x)))))</span><br></pre></td></tr></table></figure>
 <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> mystery (<span class="name">x</span> y)</span><br><span class="line">     (<span class="name">if</span> (<span class="name">null</span> y)</span><br><span class="line">         <span class="literal">nil</span></span><br><span class="line">         (<span class="name">if</span> (<span class="name">eql</span> (<span class="name">car</span> y) x)</span><br><span class="line">             <span class="number">0</span></span><br><span class="line">             (<span class="name">let</span> ((<span class="name">z</span> (<span class="name">mystery</span> x (<span class="name">cdr</span> y))))</span><br><span class="line">               (<span class="name">and</span> z (<span class="name">+</span> z <span class="number">1</span>))))))</span><br></pre></td></tr></table></figure></li>
<li>在下面的表达式中,x处应该是什么可得出结果? <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">car</span> (<span class="name">x</span> (<span class="name">cdr</span> &#x27;(a (b c) d))))</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
 <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">x</span> <span class="number">13</span> (<span class="name">/</span> <span class="number">1</span> <span class="number">0</span>))</span><br><span class="line">   <span class="number">13</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">x</span> #&#x27;list <span class="number">1</span> <span class="literal">nil</span>)</span><br><span class="line">  (<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li>只用本章介绍的操作符,定义一个函数,它接受一个表作为自变量,并返回t 如果表的元素中至少有一个类型是表.</li>
<li>给出函数的迭代和递归版本:它<ul>
<li>a. 接受一个正整数,并打印这么多数目的点.</li>
<li>b. 接受一个表,返回符号a在表中出现的次数.</li>
</ul>
</li>
<li>一位朋友想写一个函数,它返回表中所有非nil元素之和. 他写了此函数的 两个版本, 但没有一个能正确工作. 请指出错误在哪里,并给出正确的版本: <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> summit (<span class="name">lst</span>)</span><br><span class="line">     (<span class="name">remove</span> <span class="literal">nil</span> lst)</span><br><span class="line">     (<span class="name">apply</span> #&#x27;+ lst))</span><br></pre></td></tr></table></figure>
 <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> summit (<span class="name">lst</span>)</span><br><span class="line">     (<span class="name">let</span> ((<span class="name">x</span> (<span class="name">car</span> lst)))</span><br><span class="line">       (<span class="name">if</span> (<span class="name">null</span> x)</span><br><span class="line">           (<span class="name">summit</span> (<span class="name">cdr</span> lst))</span><br><span class="line">           (<span class="name">+</span> x (<span class="name">summit</span> (<span class="name">cdr</span> lst))))))</span><br></pre></td></tr></table></figure></li>
</ol>
<p>答案<br>1.<br>    - 14<br>    - (1 5)<br>1.<br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons</span> &#x27;a (<span class="name">cons</span> &#x27;b (<span class="name">cons</span> &#x27;c <span class="literal">nil</span>)))</span><br><span class="line">(<span class="name">cons</span> &#x27;a &#x27;(b c))</span><br><span class="line">(<span class="name">cons</span> &#x27;a (<span class="name">cons</span> &#x27;b &#x27;(c)))</span><br></pre></td></tr></table></figure><br>1.<br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> getForth (<span class="name">lst</span>)</span><br><span class="line">  (<span class="name">car</span> (<span class="name">cdr</span> (<span class="name">cdr</span> (<span class="name">cdr</span> lst)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> getForth (<span class="name">lst</span> n)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">result</span> lst)) </span><br><span class="line">        (<span class="name">do</span> ((<span class="name">i</span> <span class="number">2</span> (<span class="name">+</span> i <span class="number">1</span>)))</span><br><span class="line">            ((<span class="name">&gt;</span> i n) &#x27;done)</span><br><span class="line">            (<span class="name">setf</span> result (<span class="name">cdr</span> result))	    </span><br><span class="line">        )</span><br><span class="line">        (<span class="name">car</span> result)</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name">getFour</span> &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">11</span>) <span class="number">5</span>)</span><br></pre></td></tr></table></figure><br>1.<br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> getMax (<span class="name">a</span> b)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">&gt;</span> a b)</span><br><span class="line">        (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~A&quot;</span> a)</span><br><span class="line">        (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~A&quot;</span> b)</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">(<span class="name">getMax</span> <span class="number">1</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><br>1.<br>    - 判断 x 列表中是否有 nil 元素<br>    - 查找 x 在列表 y 中的下标，如果没有则为 nil<br>1.<br>    - car<br>    - or<br>    - or ‘(1) 或 apply<br>1.<br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> checkList (<span class="name">x</span>)</span><br><span class="line">    (<span class="name">and</span>  x</span><br><span class="line">          (<span class="name">or</span>  (<span class="name">listp</span> (<span class="name">car</span> x))</span><br><span class="line">                (<span class="name">checkList</span> (<span class="name">cdr</span> x)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> checkList (<span class="name">x</span>)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">null</span> x)</span><br><span class="line">        <span class="literal">nil</span></span><br><span class="line">        (<span class="name">if</span> (<span class="name">listp</span> (<span class="name">car</span> x))</span><br><span class="line">            <span class="literal">t</span></span><br><span class="line">            (<span class="name">checkList</span> (<span class="name">cdr</span> x)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; (checkList &#x27;(1 2)) // nil</span></span><br><span class="line"><span class="comment">; (checkList &#x27;(1 2 &#x27;(1))) // T</span></span><br></pre></td></tr></table></figure><br>1.<br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 接受一个正整数,并打印这么多数目的点---递归</span></span><br><span class="line">(<span class="name">defun</span> print-point (<span class="name">x</span>)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">=</span> <span class="number">0</span> x)</span><br><span class="line">        <span class="literal">nil</span></span><br><span class="line">        (<span class="name">progn</span> (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~%.&quot;</span>)</span><br><span class="line">            (<span class="name">print-point</span> (<span class="name">-</span> x <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">print-point</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure><br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 接受一个正整数,并打印这么多数目的点---迭代</span></span><br><span class="line">(<span class="name">defun</span> print-point (<span class="name">x</span>)</span><br><span class="line">    (<span class="name">do</span> ((<span class="name">i</span> <span class="number">0</span> (<span class="name">+</span> i <span class="number">1</span>)))</span><br><span class="line">        ((<span class="name">=</span> i x) &#x27;done)</span><br><span class="line">        (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~%.&quot;</span>)))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">print-point</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure><br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 接受一个列表，并返回 a 在列表里所出现的次数--递归</span></span><br><span class="line">(<span class="name">defun</span> count-a (<span class="name">lst</span>)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">null</span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">+</span> (<span class="name">if</span> (<span class="name">eql</span> &#x27;a (<span class="name">car</span> lst)) <span class="number">1</span> <span class="number">0</span>)</span><br><span class="line">            (<span class="name">count-a</span> (<span class="name">cdr</span> lst)))))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">count-a</span> &#x27;(a a a <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> a))</span><br></pre></td></tr></table></figure><br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 接受一个列表，并返回 a 在列表里所出现的次数--迭代</span></span><br><span class="line">(<span class="name">defun</span> count-a (<span class="name">lst</span>)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">count</span> <span class="number">0</span>))</span><br><span class="line">        (<span class="name">dolist</span> (<span class="name">n</span> lst)</span><br><span class="line">            (<span class="name">setf</span> count</span><br><span class="line">                (<span class="name">+</span> (<span class="name">if</span> (<span class="name">eql</span> &#x27;a n) <span class="number">1</span> <span class="number">0</span>)</span><br><span class="line">                    count)))</span><br><span class="line">        count))</span><br><span class="line">    </span><br><span class="line">(<span class="name">count-a</span> &#x27;(a a a a <span class="number">1</span> <span class="number">23</span>))</span><br></pre></td></tr></table></figure><br>1.<br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 因为 remove 并不会改变 lst 本身</span></span><br><span class="line">(<span class="name">defun</span> summit (<span class="name">lst</span>)</span><br><span class="line">    (<span class="name">setf</span> nlst (<span class="name">remove</span> <span class="literal">nil</span> lst))</span><br><span class="line">        (<span class="name">apply</span> #&#x27;+ nlst))</span><br></pre></td></tr></table></figure><br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 因为递归没有边界退出分支</span></span><br><span class="line">(<span class="name">defun</span> summit (<span class="name">lst</span>)</span><br><span class="line">    (<span class="name">if</span>  (<span class="name">null</span> lst)</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">          (<span class="name">let</span> ((<span class="name">x</span> (<span class="name">car</span> lst)))</span><br><span class="line">                (<span class="name">if</span>  (<span class="name">null</span> x)</span><br><span class="line">                    (<span class="name">summit</span> (<span class="name">cdr</span> lst))</span><br><span class="line">                    (<span class="name">+</span> x (<span class="name">summit</span> (<span class="name">cdr</span> lst)))))))</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/Blog/2022/04/24/lisp/CommonLisp%E6%95%99%E7%A8%8B/index/">Common Lisp 教程</a><a class="next" href="/Blog/2022/04/24/lisp/Lisp%E4%B9%8B%E6%A0%B9%E6%BA%90/index/">Lisp 之根源</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'e4a44394ea630529848c',
  clientSecret: '884b4deb2d55fbcc63921e12f73b58e944efa110',
  repo: 'Blog',
  owner: 'zch233',
  admin: ['zch233'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="./about/" title="About"><img class="nofancybox" src="/Blog/img/avatar.png"/></a><p>coder.</p><a class="info-icon" href="zch2333333@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zch233" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Lisp/">Lisp</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Rails/">Rails</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/SCSS/">SCSS</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">chrome调试技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/daisy/">daisy</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/relearnFE/">relearnFE</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95/">准备面试</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E7%96%91/">日常杂疑</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E8%B6%A3%E9%97%BB/">趣闻</a></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/08/27/essay/AI%E8%81%8A%E5%A4%A9prompt/index/">AI聊天prompt</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/17/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9AJS-TS/index/">TypeScript全解：JS&TS</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/16/typescript/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/index/">React 泛型组件是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：类型体操（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/15/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：类型体操（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：class（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/14/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9Aclass%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：class（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：泛型编程（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/12/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/index/">TypeScript全解：泛型编程（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/06/11/typescript/TypeScript%E5%85%A8%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8B%EF%BC%89/index/">TypeScript全解：深入对象与函数（下）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.jianshu.com/u/4b4c7aec223d" title="littleyu" target="_blank">littleyu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/Blog/." rel="nofollow">zch233.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/Blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/Blog/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/Blog/css/search.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/Blog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/Blog/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/Blog/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/Blog/js/smartresize.js?v=1.0.0"></script></div></body></html>